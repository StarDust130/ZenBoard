"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/y-prosemirror";
exports.ids = ["vendor-chunks/y-prosemirror"];
exports.modules = {

/***/ "(ssr)/./node_modules/y-prosemirror/src/lib.js":
/*!***********************************************!*\
  !*** ./node_modules/y-prosemirror/src/lib.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   absolutePositionToRelativePosition: () => (/* binding */ absolutePositionToRelativePosition),\n/* harmony export */   prosemirrorJSONToYDoc: () => (/* binding */ prosemirrorJSONToYDoc),\n/* harmony export */   prosemirrorJSONToYXmlFragment: () => (/* binding */ prosemirrorJSONToYXmlFragment),\n/* harmony export */   prosemirrorToYDoc: () => (/* binding */ prosemirrorToYDoc),\n/* harmony export */   prosemirrorToYXmlFragment: () => (/* binding */ prosemirrorToYXmlFragment),\n/* harmony export */   relativePositionToAbsolutePosition: () => (/* binding */ relativePositionToAbsolutePosition),\n/* harmony export */   setMeta: () => (/* binding */ setMeta),\n/* harmony export */   yDocToProsemirror: () => (/* binding */ yDocToProsemirror),\n/* harmony export */   yDocToProsemirrorJSON: () => (/* binding */ yDocToProsemirrorJSON),\n/* harmony export */   yXmlFragmentToProsemirror: () => (/* binding */ yXmlFragmentToProsemirror),\n/* harmony export */   yXmlFragmentToProsemirrorJSON: () => (/* binding */ yXmlFragmentToProsemirrorJSON)\n/* harmony export */ });\n/* harmony import */ var _plugins_sync_plugin_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./plugins/sync-plugin.js */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/sync-plugin.js\");\n/* harmony import */ var _plugins_keys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plugins/keys.js */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/keys.js\");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! yjs */ \"(ssr)/./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var lib0_error__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lib0/error */ \"(ssr)/./node_modules/lib0/error.js\");\n/* harmony import */ var lib0_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/map */ \"(ssr)/./node_modules/lib0/map.js\");\n/* harmony import */ var lib0_eventloop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/eventloop */ \"(ssr)/./node_modules/lib0/eventloop.js\");\n // eslint-disable-line\n\n\n // eslint-disable-line\n // eslint-disable-line\n\n\n\n\n/**\n * Either a node if type is YXmlElement or an Array of text nodes if YXmlText\n * @typedef {Map<Y.AbstractType, Node | Array<Node>>} ProsemirrorMapping\n */\n\n/**\n * Is null if no timeout is in progress.\n * Is defined if a timeout is in progress.\n * Maps from view\n * @type {Map<EditorView, Map<any, any>>|null}\n */\nlet viewsToUpdate = null\n\nconst updateMetas = () => {\n  const ups = /** @type {Map<EditorView, Map<any, any>>} */ (viewsToUpdate)\n  viewsToUpdate = null\n  ups.forEach((metas, view) => {\n    const tr = view.state.tr\n    const syncState = _plugins_keys_js__WEBPACK_IMPORTED_MODULE_0__.ySyncPluginKey.getState(view.state)\n    if (syncState && syncState.binding && !syncState.binding.isDestroyed) {\n      metas.forEach((val, key) => {\n        tr.setMeta(key, val)\n      })\n      view.dispatch(tr)\n    }\n  })\n}\n\nconst setMeta = (view, key, value) => {\n  if (!viewsToUpdate) {\n    viewsToUpdate = new Map()\n    lib0_eventloop__WEBPACK_IMPORTED_MODULE_1__.timeout(0, updateMetas)\n  }\n  lib0_map__WEBPACK_IMPORTED_MODULE_2__.setIfUndefined(viewsToUpdate, view, lib0_map__WEBPACK_IMPORTED_MODULE_2__.create).set(key, value)\n}\n\n/**\n * Transforms a Prosemirror based absolute position to a Yjs Cursor (relative position in the Yjs model).\n *\n * @param {number} pos\n * @param {Y.XmlFragment} type\n * @param {ProsemirrorMapping} mapping\n * @return {any} relative position\n */\nconst absolutePositionToRelativePosition = (pos, type, mapping) => {\n  if (pos === 0) {\n    return yjs__WEBPACK_IMPORTED_MODULE_3__.createRelativePositionFromTypeIndex(type, 0)\n  }\n  /**\n   * @type {any}\n   */\n  let n = type._first === null ? null : /** @type {Y.ContentType} */ (type._first.content).type\n  while (n !== null && type !== n) {\n    if (n instanceof yjs__WEBPACK_IMPORTED_MODULE_3__.XmlText) {\n      if (n._length >= pos) {\n        return yjs__WEBPACK_IMPORTED_MODULE_3__.createRelativePositionFromTypeIndex(n, pos)\n      } else {\n        pos -= n._length\n      }\n      if (n._item !== null && n._item.next !== null) {\n        n = /** @type {Y.ContentType} */ (n._item.next.content).type\n      } else {\n        do {\n          n = n._item === null ? null : n._item.parent\n          pos--\n        } while (n !== type && n !== null && n._item !== null && n._item.next === null)\n        if (n !== null && n !== type) {\n          // @ts-gnore we know that n.next !== null because of above loop conditition\n          n = n._item === null ? null : /** @type {Y.ContentType} */ (/** @type Y.Item */ (n._item.next).content).type\n        }\n      }\n    } else {\n      const pNodeSize = /** @type {any} */ (mapping.get(n) || { nodeSize: 0 }).nodeSize\n      if (n._first !== null && pos < pNodeSize) {\n        n = /** @type {Y.ContentType} */ (n._first.content).type\n        pos--\n      } else {\n        if (pos === 1 && n._length === 0 && pNodeSize > 1) {\n          // edge case, should end in this paragraph\n          return new yjs__WEBPACK_IMPORTED_MODULE_3__.RelativePosition(n._item === null ? null : n._item.id, n._item === null ? yjs__WEBPACK_IMPORTED_MODULE_3__.findRootTypeKey(n) : null, null)\n        }\n        pos -= pNodeSize\n        if (n._item !== null && n._item.next !== null) {\n          n = /** @type {Y.ContentType} */ (n._item.next.content).type\n        } else {\n          if (pos === 0) {\n            // set to end of n.parent\n            n = n._item === null ? n : n._item.parent\n            return new yjs__WEBPACK_IMPORTED_MODULE_3__.RelativePosition(n._item === null ? null : n._item.id, n._item === null ? yjs__WEBPACK_IMPORTED_MODULE_3__.findRootTypeKey(n) : null, null)\n          }\n          do {\n            n = /** @type {Y.Item} */ (n._item).parent\n            pos--\n          } while (n !== type && /** @type {Y.Item} */ (n._item).next === null)\n          // if n is null at this point, we have an unexpected case\n          if (n !== type) {\n            // We know that n._item.next is defined because of above loop condition\n            n = /** @type {Y.ContentType} */ (/** @type {Y.Item} */ (/** @type {Y.Item} */ (n._item).next).content).type\n          }\n        }\n      }\n    }\n    if (n === null) {\n      throw lib0_error__WEBPACK_IMPORTED_MODULE_4__.unexpectedCase()\n    }\n    if (pos === 0 && n.constructor !== yjs__WEBPACK_IMPORTED_MODULE_3__.XmlText && n !== type) { // TODO: set to <= 0\n      return createRelativePosition(n._item.parent, n._item)\n    }\n  }\n  return yjs__WEBPACK_IMPORTED_MODULE_3__.createRelativePositionFromTypeIndex(type, type._length)\n}\n\nconst createRelativePosition = (type, item) => {\n  let typeid = null\n  let tname = null\n  if (type._item === null) {\n    tname = yjs__WEBPACK_IMPORTED_MODULE_3__.findRootTypeKey(type)\n  } else {\n    typeid = yjs__WEBPACK_IMPORTED_MODULE_3__.createID(type._item.id.client, type._item.id.clock)\n  }\n  return new yjs__WEBPACK_IMPORTED_MODULE_3__.RelativePosition(typeid, tname, item.id)\n}\n\n/**\n * @param {Y.Doc} y\n * @param {Y.XmlFragment} documentType Top level type that is bound to pView\n * @param {any} relPos Encoded Yjs based relative position\n * @param {ProsemirrorMapping} mapping\n * @return {null|number}\n */\nconst relativePositionToAbsolutePosition = (y, documentType, relPos, mapping) => {\n  const decodedPos = yjs__WEBPACK_IMPORTED_MODULE_3__.createAbsolutePositionFromRelativePosition(relPos, y)\n  if (decodedPos === null || (decodedPos.type !== documentType && !yjs__WEBPACK_IMPORTED_MODULE_3__.isParentOf(documentType, decodedPos.type._item))) {\n    return null\n  }\n  let type = decodedPos.type\n  let pos = 0\n  if (type.constructor === yjs__WEBPACK_IMPORTED_MODULE_3__.XmlText) {\n    pos = decodedPos.index\n  } else if (type._item === null || !type._item.deleted) {\n    let n = type._first\n    let i = 0\n    while (i < type._length && i < decodedPos.index && n !== null) {\n      if (!n.deleted) {\n        const t = /** @type {Y.ContentType} */ (n.content).type\n        i++\n        if (t instanceof yjs__WEBPACK_IMPORTED_MODULE_3__.XmlText) {\n          pos += t._length\n        } else {\n          pos += /** @type {any} */ (mapping.get(t)).nodeSize\n        }\n      }\n      n = /** @type {Y.Item} */ (n.right)\n    }\n    pos += 1 // increase because we go out of n\n  }\n  while (type !== documentType && type._item !== null) {\n    // @ts-ignore\n    const parent = type._item.parent\n    // @ts-ignore\n    if (parent._item === null || !parent._item.deleted) {\n      pos += 1 // the start tag\n      let n = /** @type {Y.AbstractType} */ (parent)._first\n      // now iterate until we found type\n      while (n !== null) {\n        const contentType = /** @type {Y.ContentType} */ (n.content).type\n        if (contentType === type) {\n          break\n        }\n        if (!n.deleted) {\n          if (contentType instanceof yjs__WEBPACK_IMPORTED_MODULE_3__.XmlText) {\n            pos += contentType._length\n          } else {\n            pos += /** @type {any} */ (mapping.get(contentType)).nodeSize\n          }\n        }\n        n = n.right\n      }\n    }\n    type = /** @type {Y.AbstractType} */ (parent)\n  }\n  return pos - 1 // we don't count the most outer tag, because it is a fragment\n}\n\n/**\n * Utility method to convert a Prosemirror Doc Node into a Y.Doc.\n *\n * This can be used when importing existing content to Y.Doc for the first time,\n * note that this should not be used to rehydrate a Y.Doc from a database once\n * collaboration has begun as all history will be lost\n *\n * @param {Node} doc\n * @param {string} xmlFragment\n * @return {Y.Doc}\n */\nfunction prosemirrorToYDoc (doc, xmlFragment = 'prosemirror') {\n  const ydoc = new yjs__WEBPACK_IMPORTED_MODULE_3__.Doc()\n  const type = /** @type {Y.XmlFragment} */ (ydoc.get(xmlFragment, yjs__WEBPACK_IMPORTED_MODULE_3__.XmlFragment))\n  if (!type.doc) {\n    return ydoc\n  }\n\n  prosemirrorToYXmlFragment(doc, type)\n  return type.doc\n}\n\n/**\n * Utility method to update an empty Y.XmlFragment with content from a Prosemirror Doc Node.\n *\n * This can be used when importing existing content to Y.Doc for the first time,\n * note that this should not be used to rehydrate a Y.Doc from a database once\n * collaboration has begun as all history will be lost\n *\n * Note: The Y.XmlFragment does not need to be part of a Y.Doc document at the time that this\n * method is called, but it must be added before any other operations are performed on it.\n *\n * @param {Node} doc prosemirror document.\n * @param {Y.XmlFragment} [xmlFragment] If supplied, an xml fragment to be\n *   populated from the prosemirror state; otherwise a new XmlFragment will be created.\n * @return {Y.XmlFragment}\n */\nfunction prosemirrorToYXmlFragment (doc, xmlFragment) {\n  const type = xmlFragment || new yjs__WEBPACK_IMPORTED_MODULE_3__.XmlFragment()\n  const ydoc = type.doc ? type.doc : { transact: (transaction) => transaction(undefined) }\n  ;(0,_plugins_sync_plugin_js__WEBPACK_IMPORTED_MODULE_5__.updateYFragment)(ydoc, type, doc, new Map())\n  return type\n}\n\n/**\n * Utility method to convert Prosemirror compatible JSON into a Y.Doc.\n *\n * This can be used when importing existing content to Y.Doc for the first time,\n * note that this should not be used to rehydrate a Y.Doc from a database once\n * collaboration has begun as all history will be lost\n *\n * @param {Schema} schema\n * @param {any} state\n * @param {string} xmlFragment\n * @return {Y.Doc}\n */\nfunction prosemirrorJSONToYDoc (schema, state, xmlFragment = 'prosemirror') {\n  const doc = prosemirror_model__WEBPACK_IMPORTED_MODULE_6__.Node.fromJSON(schema, state)\n  return prosemirrorToYDoc(doc, xmlFragment)\n}\n\n/**\n * Utility method to convert Prosemirror compatible JSON to a Y.XmlFragment\n *\n * This can be used when importing existing content to Y.Doc for the first time,\n * note that this should not be used to rehydrate a Y.Doc from a database once\n * collaboration has begun as all history will be lost\n *\n * @param {Schema} schema\n * @param {any} state\n * @param {Y.XmlFragment} [xmlFragment] If supplied, an xml fragment to be\n *   populated from the prosemirror state; otherwise a new XmlFragment will be created.\n * @return {Y.XmlFragment}\n */\nfunction prosemirrorJSONToYXmlFragment (schema, state, xmlFragment) {\n  const doc = prosemirror_model__WEBPACK_IMPORTED_MODULE_6__.Node.fromJSON(schema, state)\n  return prosemirrorToYXmlFragment(doc, xmlFragment)\n}\n\n/**\n * Utility method to convert a Y.Doc to a Prosemirror Doc node.\n *\n * @param {Schema} schema\n * @param {Y.Doc} ydoc\n * @return {Node}\n */\nfunction yDocToProsemirror (schema, ydoc) {\n  const state = yDocToProsemirrorJSON(ydoc)\n  return prosemirror_model__WEBPACK_IMPORTED_MODULE_6__.Node.fromJSON(schema, state)\n}\n\n/**\n * Utility method to convert a Y.XmlFragment to a Prosemirror Doc node.\n *\n * @param {Schema} schema\n * @param {Y.XmlFragment} xmlFragment\n * @return {Node}\n */\nfunction yXmlFragmentToProsemirror (schema, xmlFragment) {\n  const state = yXmlFragmentToProsemirrorJSON(xmlFragment)\n  return prosemirror_model__WEBPACK_IMPORTED_MODULE_6__.Node.fromJSON(schema, state)\n}\n\n/**\n * Utility method to convert a Y.Doc to Prosemirror compatible JSON.\n *\n * @param {Y.Doc} ydoc\n * @param {string} xmlFragment\n * @return {Record<string, any>}\n */\nfunction yDocToProsemirrorJSON (\n  ydoc,\n  xmlFragment = 'prosemirror'\n) {\n  return yXmlFragmentToProsemirrorJSON(ydoc.getXmlFragment(xmlFragment))\n}\n\n/**\n * Utility method to convert a Y.Doc to Prosemirror compatible JSON.\n *\n * @param {Y.XmlFragment} xmlFragment The fragment, which must be part of a Y.Doc.\n * @return {Record<string, any>}\n */\nfunction yXmlFragmentToProsemirrorJSON (xmlFragment) {\n  const items = xmlFragment.toArray()\n\n  function serialize (item) {\n    /**\n     * @type {Object} NodeObject\n     * @property {string} NodeObject.type\n     * @property {Record<string, string>=} NodeObject.attrs\n     * @property {Array<NodeObject>=} NodeObject.content\n     */\n    let response\n\n    // TODO: Must be a better way to detect text nodes than this\n    if (!item.nodeName) {\n      const delta = item.toDelta()\n      response = delta.map((d) => {\n        const text = {\n          type: 'text',\n          text: d.insert\n        }\n\n        if (d.attributes) {\n          text.marks = Object.keys(d.attributes).map((type) => {\n            const attrs = d.attributes[type]\n            const mark = {\n              type\n            }\n\n            if (Object.keys(attrs)) {\n              mark.attrs = attrs\n            }\n\n            return mark\n          })\n        }\n        return text\n      })\n    } else {\n      response = {\n        type: item.nodeName\n      }\n\n      const attrs = item.getAttributes()\n      if (Object.keys(attrs).length) {\n        response.attrs = attrs\n      }\n\n      const children = item.toArray()\n      if (children.length) {\n        response.content = children.map(serialize).flat()\n      }\n    }\n\n    return response\n  }\n\n  return {\n    type: 'doc',\n    content: items.map(serialize)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveS1wcm9zZW1pcnJvci9zcmMvbGliLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwRDtBQUNSO0FBQzFCO0FBQ3FCO0FBQ0c7QUFDYjtBQUNKO0FBQ1k7O0FBRTNDO0FBQ0E7QUFDQSxhQUFhLHlDQUF5QztBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLGdDQUFnQztBQUN6RDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNERBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRU87QUFDUDtBQUNBO0FBQ0EsSUFBSSxtREFBaUI7QUFDckI7QUFDQSxFQUFFLG9EQUFrQixzQkFBc0IsNENBQVU7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQixXQUFXLG9CQUFvQjtBQUMvQixZQUFZLEtBQUs7QUFDakI7QUFDTztBQUNQO0FBQ0EsV0FBVyxvRUFBcUM7QUFDaEQ7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLG1EQUFtRCxlQUFlO0FBQ2xFO0FBQ0EscUJBQXFCLHdDQUFTO0FBQzlCO0FBQ0EsZUFBZSxvRUFBcUM7QUFDcEQsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixlQUFlO0FBQ3RDLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLG1EQUFtRCxlQUFlO0FBQ2xFO0FBQ0E7QUFDQSxNQUFNO0FBQ04sbUNBQW1DLEtBQUssd0JBQXdCLGFBQWE7QUFDN0U7QUFDQSx1QkFBdUIsZUFBZTtBQUN0QztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EscUJBQXFCLGlEQUFrQiwwREFBMEQsZ0RBQWlCO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixlQUFlO0FBQ3hDLFVBQVU7QUFDVjtBQUNB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QUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFlBQVk7QUFDWjtBQUNPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IseUJBQXlCO0FBQzNDLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemVuYm9hcmQvLi9ub2RlX21vZHVsZXMveS1wcm9zZW1pcnJvci9zcmMvbGliLmpzPzI1MGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXBkYXRlWUZyYWdtZW50IH0gZnJvbSAnLi9wbHVnaW5zL3N5bmMtcGx1Z2luLmpzJyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5pbXBvcnQgeyB5U3luY1BsdWdpbktleSB9IGZyb20gJy4vcGx1Z2lucy9rZXlzLmpzJ1xuaW1wb3J0ICogYXMgWSBmcm9tICd5anMnXG5pbXBvcnQgeyBFZGl0b3JWaWV3IH0gZnJvbSAncHJvc2VtaXJyb3ItdmlldycgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuaW1wb3J0IHsgTm9kZSwgU2NoZW1hIH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbmltcG9ydCAqIGFzIGVycm9yIGZyb20gJ2xpYjAvZXJyb3InXG5pbXBvcnQgKiBhcyBtYXAgZnJvbSAnbGliMC9tYXAnXG5pbXBvcnQgKiBhcyBldmVudGxvb3AgZnJvbSAnbGliMC9ldmVudGxvb3AnXG5cbi8qKlxuICogRWl0aGVyIGEgbm9kZSBpZiB0eXBlIGlzIFlYbWxFbGVtZW50IG9yIGFuIEFycmF5IG9mIHRleHQgbm9kZXMgaWYgWVhtbFRleHRcbiAqIEB0eXBlZGVmIHtNYXA8WS5BYnN0cmFjdFR5cGUsIE5vZGUgfCBBcnJheTxOb2RlPj59IFByb3NlbWlycm9yTWFwcGluZ1xuICovXG5cbi8qKlxuICogSXMgbnVsbCBpZiBubyB0aW1lb3V0IGlzIGluIHByb2dyZXNzLlxuICogSXMgZGVmaW5lZCBpZiBhIHRpbWVvdXQgaXMgaW4gcHJvZ3Jlc3MuXG4gKiBNYXBzIGZyb20gdmlld1xuICogQHR5cGUge01hcDxFZGl0b3JWaWV3LCBNYXA8YW55LCBhbnk+PnxudWxsfVxuICovXG5sZXQgdmlld3NUb1VwZGF0ZSA9IG51bGxcblxuY29uc3QgdXBkYXRlTWV0YXMgPSAoKSA9PiB7XG4gIGNvbnN0IHVwcyA9IC8qKiBAdHlwZSB7TWFwPEVkaXRvclZpZXcsIE1hcDxhbnksIGFueT4+fSAqLyAodmlld3NUb1VwZGF0ZSlcbiAgdmlld3NUb1VwZGF0ZSA9IG51bGxcbiAgdXBzLmZvckVhY2goKG1ldGFzLCB2aWV3KSA9PiB7XG4gICAgY29uc3QgdHIgPSB2aWV3LnN0YXRlLnRyXG4gICAgY29uc3Qgc3luY1N0YXRlID0geVN5bmNQbHVnaW5LZXkuZ2V0U3RhdGUodmlldy5zdGF0ZSlcbiAgICBpZiAoc3luY1N0YXRlICYmIHN5bmNTdGF0ZS5iaW5kaW5nICYmICFzeW5jU3RhdGUuYmluZGluZy5pc0Rlc3Ryb3llZCkge1xuICAgICAgbWV0YXMuZm9yRWFjaCgodmFsLCBrZXkpID0+IHtcbiAgICAgICAgdHIuc2V0TWV0YShrZXksIHZhbClcbiAgICAgIH0pXG4gICAgICB2aWV3LmRpc3BhdGNoKHRyKVxuICAgIH1cbiAgfSlcbn1cblxuZXhwb3J0IGNvbnN0IHNldE1ldGEgPSAodmlldywga2V5LCB2YWx1ZSkgPT4ge1xuICBpZiAoIXZpZXdzVG9VcGRhdGUpIHtcbiAgICB2aWV3c1RvVXBkYXRlID0gbmV3IE1hcCgpXG4gICAgZXZlbnRsb29wLnRpbWVvdXQoMCwgdXBkYXRlTWV0YXMpXG4gIH1cbiAgbWFwLnNldElmVW5kZWZpbmVkKHZpZXdzVG9VcGRhdGUsIHZpZXcsIG1hcC5jcmVhdGUpLnNldChrZXksIHZhbHVlKVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgYSBQcm9zZW1pcnJvciBiYXNlZCBhYnNvbHV0ZSBwb3NpdGlvbiB0byBhIFlqcyBDdXJzb3IgKHJlbGF0aXZlIHBvc2l0aW9uIGluIHRoZSBZanMgbW9kZWwpLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3NcbiAqIEBwYXJhbSB7WS5YbWxGcmFnbWVudH0gdHlwZVxuICogQHBhcmFtIHtQcm9zZW1pcnJvck1hcHBpbmd9IG1hcHBpbmdcbiAqIEByZXR1cm4ge2FueX0gcmVsYXRpdmUgcG9zaXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGFic29sdXRlUG9zaXRpb25Ub1JlbGF0aXZlUG9zaXRpb24gPSAocG9zLCB0eXBlLCBtYXBwaW5nKSA9PiB7XG4gIGlmIChwb3MgPT09IDApIHtcbiAgICByZXR1cm4gWS5jcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbVR5cGVJbmRleCh0eXBlLCAwKVxuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgbGV0IG4gPSB0eXBlLl9maXJzdCA9PT0gbnVsbCA/IG51bGwgOiAvKiogQHR5cGUge1kuQ29udGVudFR5cGV9ICovICh0eXBlLl9maXJzdC5jb250ZW50KS50eXBlXG4gIHdoaWxlIChuICE9PSBudWxsICYmIHR5cGUgIT09IG4pIHtcbiAgICBpZiAobiBpbnN0YW5jZW9mIFkuWG1sVGV4dCkge1xuICAgICAgaWYgKG4uX2xlbmd0aCA+PSBwb3MpIHtcbiAgICAgICAgcmV0dXJuIFkuY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21UeXBlSW5kZXgobiwgcG9zKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zIC09IG4uX2xlbmd0aFxuICAgICAgfVxuICAgICAgaWYgKG4uX2l0ZW0gIT09IG51bGwgJiYgbi5faXRlbS5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIG4gPSAvKiogQHR5cGUge1kuQ29udGVudFR5cGV9ICovIChuLl9pdGVtLm5leHQuY29udGVudCkudHlwZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIG4gPSBuLl9pdGVtID09PSBudWxsID8gbnVsbCA6IG4uX2l0ZW0ucGFyZW50XG4gICAgICAgICAgcG9zLS1cbiAgICAgICAgfSB3aGlsZSAobiAhPT0gdHlwZSAmJiBuICE9PSBudWxsICYmIG4uX2l0ZW0gIT09IG51bGwgJiYgbi5faXRlbS5uZXh0ID09PSBudWxsKVxuICAgICAgICBpZiAobiAhPT0gbnVsbCAmJiBuICE9PSB0eXBlKSB7XG4gICAgICAgICAgLy8gQHRzLWdub3JlIHdlIGtub3cgdGhhdCBuLm5leHQgIT09IG51bGwgYmVjYXVzZSBvZiBhYm92ZSBsb29wIGNvbmRpdGl0aW9uXG4gICAgICAgICAgbiA9IG4uX2l0ZW0gPT09IG51bGwgPyBudWxsIDogLyoqIEB0eXBlIHtZLkNvbnRlbnRUeXBlfSAqLyAoLyoqIEB0eXBlIFkuSXRlbSAqLyAobi5faXRlbS5uZXh0KS5jb250ZW50KS50eXBlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcE5vZGVTaXplID0gLyoqIEB0eXBlIHthbnl9ICovIChtYXBwaW5nLmdldChuKSB8fCB7IG5vZGVTaXplOiAwIH0pLm5vZGVTaXplXG4gICAgICBpZiAobi5fZmlyc3QgIT09IG51bGwgJiYgcG9zIDwgcE5vZGVTaXplKSB7XG4gICAgICAgIG4gPSAvKiogQHR5cGUge1kuQ29udGVudFR5cGV9ICovIChuLl9maXJzdC5jb250ZW50KS50eXBlXG4gICAgICAgIHBvcy0tXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocG9zID09PSAxICYmIG4uX2xlbmd0aCA9PT0gMCAmJiBwTm9kZVNpemUgPiAxKSB7XG4gICAgICAgICAgLy8gZWRnZSBjYXNlLCBzaG91bGQgZW5kIGluIHRoaXMgcGFyYWdyYXBoXG4gICAgICAgICAgcmV0dXJuIG5ldyBZLlJlbGF0aXZlUG9zaXRpb24obi5faXRlbSA9PT0gbnVsbCA/IG51bGwgOiBuLl9pdGVtLmlkLCBuLl9pdGVtID09PSBudWxsID8gWS5maW5kUm9vdFR5cGVLZXkobikgOiBudWxsLCBudWxsKVxuICAgICAgICB9XG4gICAgICAgIHBvcyAtPSBwTm9kZVNpemVcbiAgICAgICAgaWYgKG4uX2l0ZW0gIT09IG51bGwgJiYgbi5faXRlbS5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAgICAgbiA9IC8qKiBAdHlwZSB7WS5Db250ZW50VHlwZX0gKi8gKG4uX2l0ZW0ubmV4dC5jb250ZW50KS50eXBlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHBvcyA9PT0gMCkge1xuICAgICAgICAgICAgLy8gc2V0IHRvIGVuZCBvZiBuLnBhcmVudFxuICAgICAgICAgICAgbiA9IG4uX2l0ZW0gPT09IG51bGwgPyBuIDogbi5faXRlbS5wYXJlbnRcbiAgICAgICAgICAgIHJldHVybiBuZXcgWS5SZWxhdGl2ZVBvc2l0aW9uKG4uX2l0ZW0gPT09IG51bGwgPyBudWxsIDogbi5faXRlbS5pZCwgbi5faXRlbSA9PT0gbnVsbCA/IFkuZmluZFJvb3RUeXBlS2V5KG4pIDogbnVsbCwgbnVsbClcbiAgICAgICAgICB9XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgbiA9IC8qKiBAdHlwZSB7WS5JdGVtfSAqLyAobi5faXRlbSkucGFyZW50XG4gICAgICAgICAgICBwb3MtLVxuICAgICAgICAgIH0gd2hpbGUgKG4gIT09IHR5cGUgJiYgLyoqIEB0eXBlIHtZLkl0ZW19ICovIChuLl9pdGVtKS5uZXh0ID09PSBudWxsKVxuICAgICAgICAgIC8vIGlmIG4gaXMgbnVsbCBhdCB0aGlzIHBvaW50LCB3ZSBoYXZlIGFuIHVuZXhwZWN0ZWQgY2FzZVxuICAgICAgICAgIGlmIChuICE9PSB0eXBlKSB7XG4gICAgICAgICAgICAvLyBXZSBrbm93IHRoYXQgbi5faXRlbS5uZXh0IGlzIGRlZmluZWQgYmVjYXVzZSBvZiBhYm92ZSBsb29wIGNvbmRpdGlvblxuICAgICAgICAgICAgbiA9IC8qKiBAdHlwZSB7WS5Db250ZW50VHlwZX0gKi8gKC8qKiBAdHlwZSB7WS5JdGVtfSAqLyAoLyoqIEB0eXBlIHtZLkl0ZW19ICovIChuLl9pdGVtKS5uZXh0KS5jb250ZW50KS50eXBlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBlcnJvci51bmV4cGVjdGVkQ2FzZSgpXG4gICAgfVxuICAgIGlmIChwb3MgPT09IDAgJiYgbi5jb25zdHJ1Y3RvciAhPT0gWS5YbWxUZXh0ICYmIG4gIT09IHR5cGUpIHsgLy8gVE9ETzogc2V0IHRvIDw9IDBcbiAgICAgIHJldHVybiBjcmVhdGVSZWxhdGl2ZVBvc2l0aW9uKG4uX2l0ZW0ucGFyZW50LCBuLl9pdGVtKVxuICAgIH1cbiAgfVxuICByZXR1cm4gWS5jcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbVR5cGVJbmRleCh0eXBlLCB0eXBlLl9sZW5ndGgpXG59XG5cbmNvbnN0IGNyZWF0ZVJlbGF0aXZlUG9zaXRpb24gPSAodHlwZSwgaXRlbSkgPT4ge1xuICBsZXQgdHlwZWlkID0gbnVsbFxuICBsZXQgdG5hbWUgPSBudWxsXG4gIGlmICh0eXBlLl9pdGVtID09PSBudWxsKSB7XG4gICAgdG5hbWUgPSBZLmZpbmRSb290VHlwZUtleSh0eXBlKVxuICB9IGVsc2Uge1xuICAgIHR5cGVpZCA9IFkuY3JlYXRlSUQodHlwZS5faXRlbS5pZC5jbGllbnQsIHR5cGUuX2l0ZW0uaWQuY2xvY2spXG4gIH1cbiAgcmV0dXJuIG5ldyBZLlJlbGF0aXZlUG9zaXRpb24odHlwZWlkLCB0bmFtZSwgaXRlbS5pZClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1kuRG9jfSB5XG4gKiBAcGFyYW0ge1kuWG1sRnJhZ21lbnR9IGRvY3VtZW50VHlwZSBUb3AgbGV2ZWwgdHlwZSB0aGF0IGlzIGJvdW5kIHRvIHBWaWV3XG4gKiBAcGFyYW0ge2FueX0gcmVsUG9zIEVuY29kZWQgWWpzIGJhc2VkIHJlbGF0aXZlIHBvc2l0aW9uXG4gKiBAcGFyYW0ge1Byb3NlbWlycm9yTWFwcGluZ30gbWFwcGluZ1xuICogQHJldHVybiB7bnVsbHxudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCByZWxhdGl2ZVBvc2l0aW9uVG9BYnNvbHV0ZVBvc2l0aW9uID0gKHksIGRvY3VtZW50VHlwZSwgcmVsUG9zLCBtYXBwaW5nKSA9PiB7XG4gIGNvbnN0IGRlY29kZWRQb3MgPSBZLmNyZWF0ZUFic29sdXRlUG9zaXRpb25Gcm9tUmVsYXRpdmVQb3NpdGlvbihyZWxQb3MsIHkpXG4gIGlmIChkZWNvZGVkUG9zID09PSBudWxsIHx8IChkZWNvZGVkUG9zLnR5cGUgIT09IGRvY3VtZW50VHlwZSAmJiAhWS5pc1BhcmVudE9mKGRvY3VtZW50VHlwZSwgZGVjb2RlZFBvcy50eXBlLl9pdGVtKSkpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIGxldCB0eXBlID0gZGVjb2RlZFBvcy50eXBlXG4gIGxldCBwb3MgPSAwXG4gIGlmICh0eXBlLmNvbnN0cnVjdG9yID09PSBZLlhtbFRleHQpIHtcbiAgICBwb3MgPSBkZWNvZGVkUG9zLmluZGV4XG4gIH0gZWxzZSBpZiAodHlwZS5faXRlbSA9PT0gbnVsbCB8fCAhdHlwZS5faXRlbS5kZWxldGVkKSB7XG4gICAgbGV0IG4gPSB0eXBlLl9maXJzdFxuICAgIGxldCBpID0gMFxuICAgIHdoaWxlIChpIDwgdHlwZS5fbGVuZ3RoICYmIGkgPCBkZWNvZGVkUG9zLmluZGV4ICYmIG4gIT09IG51bGwpIHtcbiAgICAgIGlmICghbi5kZWxldGVkKSB7XG4gICAgICAgIGNvbnN0IHQgPSAvKiogQHR5cGUge1kuQ29udGVudFR5cGV9ICovIChuLmNvbnRlbnQpLnR5cGVcbiAgICAgICAgaSsrXG4gICAgICAgIGlmICh0IGluc3RhbmNlb2YgWS5YbWxUZXh0KSB7XG4gICAgICAgICAgcG9zICs9IHQuX2xlbmd0aFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvcyArPSAvKiogQHR5cGUge2FueX0gKi8gKG1hcHBpbmcuZ2V0KHQpKS5ub2RlU2l6ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuID0gLyoqIEB0eXBlIHtZLkl0ZW19ICovIChuLnJpZ2h0KVxuICAgIH1cbiAgICBwb3MgKz0gMSAvLyBpbmNyZWFzZSBiZWNhdXNlIHdlIGdvIG91dCBvZiBuXG4gIH1cbiAgd2hpbGUgKHR5cGUgIT09IGRvY3VtZW50VHlwZSAmJiB0eXBlLl9pdGVtICE9PSBudWxsKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IHBhcmVudCA9IHR5cGUuX2l0ZW0ucGFyZW50XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChwYXJlbnQuX2l0ZW0gPT09IG51bGwgfHwgIXBhcmVudC5faXRlbS5kZWxldGVkKSB7XG4gICAgICBwb3MgKz0gMSAvLyB0aGUgc3RhcnQgdGFnXG4gICAgICBsZXQgbiA9IC8qKiBAdHlwZSB7WS5BYnN0cmFjdFR5cGV9ICovIChwYXJlbnQpLl9maXJzdFxuICAgICAgLy8gbm93IGl0ZXJhdGUgdW50aWwgd2UgZm91bmQgdHlwZVxuICAgICAgd2hpbGUgKG4gIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSAvKiogQHR5cGUge1kuQ29udGVudFR5cGV9ICovIChuLmNvbnRlbnQpLnR5cGVcbiAgICAgICAgaWYgKGNvbnRlbnRUeXBlID09PSB0eXBlKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW4uZGVsZXRlZCkge1xuICAgICAgICAgIGlmIChjb250ZW50VHlwZSBpbnN0YW5jZW9mIFkuWG1sVGV4dCkge1xuICAgICAgICAgICAgcG9zICs9IGNvbnRlbnRUeXBlLl9sZW5ndGhcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zICs9IC8qKiBAdHlwZSB7YW55fSAqLyAobWFwcGluZy5nZXQoY29udGVudFR5cGUpKS5ub2RlU2l6ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuID0gbi5yaWdodFxuICAgICAgfVxuICAgIH1cbiAgICB0eXBlID0gLyoqIEB0eXBlIHtZLkFic3RyYWN0VHlwZX0gKi8gKHBhcmVudClcbiAgfVxuICByZXR1cm4gcG9zIC0gMSAvLyB3ZSBkb24ndCBjb3VudCB0aGUgbW9zdCBvdXRlciB0YWcsIGJlY2F1c2UgaXQgaXMgYSBmcmFnbWVudFxufVxuXG4vKipcbiAqIFV0aWxpdHkgbWV0aG9kIHRvIGNvbnZlcnQgYSBQcm9zZW1pcnJvciBEb2MgTm9kZSBpbnRvIGEgWS5Eb2MuXG4gKlxuICogVGhpcyBjYW4gYmUgdXNlZCB3aGVuIGltcG9ydGluZyBleGlzdGluZyBjb250ZW50IHRvIFkuRG9jIGZvciB0aGUgZmlyc3QgdGltZSxcbiAqIG5vdGUgdGhhdCB0aGlzIHNob3VsZCBub3QgYmUgdXNlZCB0byByZWh5ZHJhdGUgYSBZLkRvYyBmcm9tIGEgZGF0YWJhc2Ugb25jZVxuICogY29sbGFib3JhdGlvbiBoYXMgYmVndW4gYXMgYWxsIGhpc3Rvcnkgd2lsbCBiZSBsb3N0XG4gKlxuICogQHBhcmFtIHtOb2RlfSBkb2NcbiAqIEBwYXJhbSB7c3RyaW5nfSB4bWxGcmFnbWVudFxuICogQHJldHVybiB7WS5Eb2N9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9zZW1pcnJvclRvWURvYyAoZG9jLCB4bWxGcmFnbWVudCA9ICdwcm9zZW1pcnJvcicpIHtcbiAgY29uc3QgeWRvYyA9IG5ldyBZLkRvYygpXG4gIGNvbnN0IHR5cGUgPSAvKiogQHR5cGUge1kuWG1sRnJhZ21lbnR9ICovICh5ZG9jLmdldCh4bWxGcmFnbWVudCwgWS5YbWxGcmFnbWVudCkpXG4gIGlmICghdHlwZS5kb2MpIHtcbiAgICByZXR1cm4geWRvY1xuICB9XG5cbiAgcHJvc2VtaXJyb3JUb1lYbWxGcmFnbWVudChkb2MsIHR5cGUpXG4gIHJldHVybiB0eXBlLmRvY1xufVxuXG4vKipcbiAqIFV0aWxpdHkgbWV0aG9kIHRvIHVwZGF0ZSBhbiBlbXB0eSBZLlhtbEZyYWdtZW50IHdpdGggY29udGVudCBmcm9tIGEgUHJvc2VtaXJyb3IgRG9jIE5vZGUuXG4gKlxuICogVGhpcyBjYW4gYmUgdXNlZCB3aGVuIGltcG9ydGluZyBleGlzdGluZyBjb250ZW50IHRvIFkuRG9jIGZvciB0aGUgZmlyc3QgdGltZSxcbiAqIG5vdGUgdGhhdCB0aGlzIHNob3VsZCBub3QgYmUgdXNlZCB0byByZWh5ZHJhdGUgYSBZLkRvYyBmcm9tIGEgZGF0YWJhc2Ugb25jZVxuICogY29sbGFib3JhdGlvbiBoYXMgYmVndW4gYXMgYWxsIGhpc3Rvcnkgd2lsbCBiZSBsb3N0XG4gKlxuICogTm90ZTogVGhlIFkuWG1sRnJhZ21lbnQgZG9lcyBub3QgbmVlZCB0byBiZSBwYXJ0IG9mIGEgWS5Eb2MgZG9jdW1lbnQgYXQgdGhlIHRpbWUgdGhhdCB0aGlzXG4gKiBtZXRob2QgaXMgY2FsbGVkLCBidXQgaXQgbXVzdCBiZSBhZGRlZCBiZWZvcmUgYW55IG90aGVyIG9wZXJhdGlvbnMgYXJlIHBlcmZvcm1lZCBvbiBpdC5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IGRvYyBwcm9zZW1pcnJvciBkb2N1bWVudC5cbiAqIEBwYXJhbSB7WS5YbWxGcmFnbWVudH0gW3htbEZyYWdtZW50XSBJZiBzdXBwbGllZCwgYW4geG1sIGZyYWdtZW50IHRvIGJlXG4gKiAgIHBvcHVsYXRlZCBmcm9tIHRoZSBwcm9zZW1pcnJvciBzdGF0ZTsgb3RoZXJ3aXNlIGEgbmV3IFhtbEZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZC5cbiAqIEByZXR1cm4ge1kuWG1sRnJhZ21lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9zZW1pcnJvclRvWVhtbEZyYWdtZW50IChkb2MsIHhtbEZyYWdtZW50KSB7XG4gIGNvbnN0IHR5cGUgPSB4bWxGcmFnbWVudCB8fCBuZXcgWS5YbWxGcmFnbWVudCgpXG4gIGNvbnN0IHlkb2MgPSB0eXBlLmRvYyA/IHR5cGUuZG9jIDogeyB0cmFuc2FjdDogKHRyYW5zYWN0aW9uKSA9PiB0cmFuc2FjdGlvbih1bmRlZmluZWQpIH1cbiAgdXBkYXRlWUZyYWdtZW50KHlkb2MsIHR5cGUsIGRvYywgbmV3IE1hcCgpKVxuICByZXR1cm4gdHlwZVxufVxuXG4vKipcbiAqIFV0aWxpdHkgbWV0aG9kIHRvIGNvbnZlcnQgUHJvc2VtaXJyb3IgY29tcGF0aWJsZSBKU09OIGludG8gYSBZLkRvYy5cbiAqXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHdoZW4gaW1wb3J0aW5nIGV4aXN0aW5nIGNvbnRlbnQgdG8gWS5Eb2MgZm9yIHRoZSBmaXJzdCB0aW1lLFxuICogbm90ZSB0aGF0IHRoaXMgc2hvdWxkIG5vdCBiZSB1c2VkIHRvIHJlaHlkcmF0ZSBhIFkuRG9jIGZyb20gYSBkYXRhYmFzZSBvbmNlXG4gKiBjb2xsYWJvcmF0aW9uIGhhcyBiZWd1biBhcyBhbGwgaGlzdG9yeSB3aWxsIGJlIGxvc3RcbiAqXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAcGFyYW0ge2FueX0gc3RhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB4bWxGcmFnbWVudFxuICogQHJldHVybiB7WS5Eb2N9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9zZW1pcnJvckpTT05Ub1lEb2MgKHNjaGVtYSwgc3RhdGUsIHhtbEZyYWdtZW50ID0gJ3Byb3NlbWlycm9yJykge1xuICBjb25zdCBkb2MgPSBOb2RlLmZyb21KU09OKHNjaGVtYSwgc3RhdGUpXG4gIHJldHVybiBwcm9zZW1pcnJvclRvWURvYyhkb2MsIHhtbEZyYWdtZW50KVxufVxuXG4vKipcbiAqIFV0aWxpdHkgbWV0aG9kIHRvIGNvbnZlcnQgUHJvc2VtaXJyb3IgY29tcGF0aWJsZSBKU09OIHRvIGEgWS5YbWxGcmFnbWVudFxuICpcbiAqIFRoaXMgY2FuIGJlIHVzZWQgd2hlbiBpbXBvcnRpbmcgZXhpc3RpbmcgY29udGVudCB0byBZLkRvYyBmb3IgdGhlIGZpcnN0IHRpbWUsXG4gKiBub3RlIHRoYXQgdGhpcyBzaG91bGQgbm90IGJlIHVzZWQgdG8gcmVoeWRyYXRlIGEgWS5Eb2MgZnJvbSBhIGRhdGFiYXNlIG9uY2VcbiAqIGNvbGxhYm9yYXRpb24gaGFzIGJlZ3VuIGFzIGFsbCBoaXN0b3J5IHdpbGwgYmUgbG9zdFxuICpcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEBwYXJhbSB7YW55fSBzdGF0ZVxuICogQHBhcmFtIHtZLlhtbEZyYWdtZW50fSBbeG1sRnJhZ21lbnRdIElmIHN1cHBsaWVkLCBhbiB4bWwgZnJhZ21lbnQgdG8gYmVcbiAqICAgcG9wdWxhdGVkIGZyb20gdGhlIHByb3NlbWlycm9yIHN0YXRlOyBvdGhlcndpc2UgYSBuZXcgWG1sRnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkLlxuICogQHJldHVybiB7WS5YbWxGcmFnbWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb3NlbWlycm9ySlNPTlRvWVhtbEZyYWdtZW50IChzY2hlbWEsIHN0YXRlLCB4bWxGcmFnbWVudCkge1xuICBjb25zdCBkb2MgPSBOb2RlLmZyb21KU09OKHNjaGVtYSwgc3RhdGUpXG4gIHJldHVybiBwcm9zZW1pcnJvclRvWVhtbEZyYWdtZW50KGRvYywgeG1sRnJhZ21lbnQpXG59XG5cbi8qKlxuICogVXRpbGl0eSBtZXRob2QgdG8gY29udmVydCBhIFkuRG9jIHRvIGEgUHJvc2VtaXJyb3IgRG9jIG5vZGUuXG4gKlxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICogQHBhcmFtIHtZLkRvY30geWRvY1xuICogQHJldHVybiB7Tm9kZX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHlEb2NUb1Byb3NlbWlycm9yIChzY2hlbWEsIHlkb2MpIHtcbiAgY29uc3Qgc3RhdGUgPSB5RG9jVG9Qcm9zZW1pcnJvckpTT04oeWRvYylcbiAgcmV0dXJuIE5vZGUuZnJvbUpTT04oc2NoZW1hLCBzdGF0ZSlcbn1cblxuLyoqXG4gKiBVdGlsaXR5IG1ldGhvZCB0byBjb252ZXJ0IGEgWS5YbWxGcmFnbWVudCB0byBhIFByb3NlbWlycm9yIERvYyBub2RlLlxuICpcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEBwYXJhbSB7WS5YbWxGcmFnbWVudH0geG1sRnJhZ21lbnRcbiAqIEByZXR1cm4ge05vZGV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB5WG1sRnJhZ21lbnRUb1Byb3NlbWlycm9yIChzY2hlbWEsIHhtbEZyYWdtZW50KSB7XG4gIGNvbnN0IHN0YXRlID0geVhtbEZyYWdtZW50VG9Qcm9zZW1pcnJvckpTT04oeG1sRnJhZ21lbnQpXG4gIHJldHVybiBOb2RlLmZyb21KU09OKHNjaGVtYSwgc3RhdGUpXG59XG5cbi8qKlxuICogVXRpbGl0eSBtZXRob2QgdG8gY29udmVydCBhIFkuRG9jIHRvIFByb3NlbWlycm9yIGNvbXBhdGlibGUgSlNPTi5cbiAqXG4gKiBAcGFyYW0ge1kuRG9jfSB5ZG9jXG4gKiBAcGFyYW0ge3N0cmluZ30geG1sRnJhZ21lbnRcbiAqIEByZXR1cm4ge1JlY29yZDxzdHJpbmcsIGFueT59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB5RG9jVG9Qcm9zZW1pcnJvckpTT04gKFxuICB5ZG9jLFxuICB4bWxGcmFnbWVudCA9ICdwcm9zZW1pcnJvcidcbikge1xuICByZXR1cm4geVhtbEZyYWdtZW50VG9Qcm9zZW1pcnJvckpTT04oeWRvYy5nZXRYbWxGcmFnbWVudCh4bWxGcmFnbWVudCkpXG59XG5cbi8qKlxuICogVXRpbGl0eSBtZXRob2QgdG8gY29udmVydCBhIFkuRG9jIHRvIFByb3NlbWlycm9yIGNvbXBhdGlibGUgSlNPTi5cbiAqXG4gKiBAcGFyYW0ge1kuWG1sRnJhZ21lbnR9IHhtbEZyYWdtZW50IFRoZSBmcmFnbWVudCwgd2hpY2ggbXVzdCBiZSBwYXJ0IG9mIGEgWS5Eb2MuXG4gKiBAcmV0dXJuIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fVxuICovXG5leHBvcnQgZnVuY3Rpb24geVhtbEZyYWdtZW50VG9Qcm9zZW1pcnJvckpTT04gKHhtbEZyYWdtZW50KSB7XG4gIGNvbnN0IGl0ZW1zID0geG1sRnJhZ21lbnQudG9BcnJheSgpXG5cbiAgZnVuY3Rpb24gc2VyaWFsaXplIChpdGVtKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge09iamVjdH0gTm9kZU9iamVjdFxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBOb2RlT2JqZWN0LnR5cGVcbiAgICAgKiBAcHJvcGVydHkge1JlY29yZDxzdHJpbmcsIHN0cmluZz49fSBOb2RlT2JqZWN0LmF0dHJzXG4gICAgICogQHByb3BlcnR5IHtBcnJheTxOb2RlT2JqZWN0Pj19IE5vZGVPYmplY3QuY29udGVudFxuICAgICAqL1xuICAgIGxldCByZXNwb25zZVxuXG4gICAgLy8gVE9ETzogTXVzdCBiZSBhIGJldHRlciB3YXkgdG8gZGV0ZWN0IHRleHQgbm9kZXMgdGhhbiB0aGlzXG4gICAgaWYgKCFpdGVtLm5vZGVOYW1lKSB7XG4gICAgICBjb25zdCBkZWx0YSA9IGl0ZW0udG9EZWx0YSgpXG4gICAgICByZXNwb25zZSA9IGRlbHRhLm1hcCgoZCkgPT4ge1xuICAgICAgICBjb25zdCB0ZXh0ID0ge1xuICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICB0ZXh0OiBkLmluc2VydFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGQuYXR0cmlidXRlcykge1xuICAgICAgICAgIHRleHQubWFya3MgPSBPYmplY3Qua2V5cyhkLmF0dHJpYnV0ZXMpLm1hcCgodHlwZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXR0cnMgPSBkLmF0dHJpYnV0ZXNbdHlwZV1cbiAgICAgICAgICAgIGNvbnN0IG1hcmsgPSB7XG4gICAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGF0dHJzKSkge1xuICAgICAgICAgICAgICBtYXJrLmF0dHJzID0gYXR0cnNcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1hcmtcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0XG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICByZXNwb25zZSA9IHtcbiAgICAgICAgdHlwZTogaXRlbS5ub2RlTmFtZVxuICAgICAgfVxuXG4gICAgICBjb25zdCBhdHRycyA9IGl0ZW0uZ2V0QXR0cmlidXRlcygpXG4gICAgICBpZiAoT2JqZWN0LmtleXMoYXR0cnMpLmxlbmd0aCkge1xuICAgICAgICByZXNwb25zZS5hdHRycyA9IGF0dHJzXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gaXRlbS50b0FycmF5KClcbiAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgcmVzcG9uc2UuY29udGVudCA9IGNoaWxkcmVuLm1hcChzZXJpYWxpemUpLmZsYXQoKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnZG9jJyxcbiAgICBjb250ZW50OiBpdGVtcy5tYXAoc2VyaWFsaXplKVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/y-prosemirror/src/lib.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/y-prosemirror/src/plugins/cursor-plugin.js":
/*!*****************************************************************!*\
  !*** ./node_modules/y-prosemirror/src/plugins/cursor-plugin.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDecorations: () => (/* binding */ createDecorations),\n/* harmony export */   defaultCursorBuilder: () => (/* binding */ defaultCursorBuilder),\n/* harmony export */   defaultSelectionBuilder: () => (/* binding */ defaultSelectionBuilder),\n/* harmony export */   yCursorPlugin: () => (/* binding */ yCursorPlugin)\n/* harmony export */ });\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! yjs */ \"(ssr)/./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-view */ \"(ssr)/./node_modules/prosemirror-view/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var y_protocols_awareness__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! y-protocols/awareness */ \"(ssr)/./node_modules/y-protocols/awareness.js\");\n/* harmony import */ var _lib_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib.js */ \"(ssr)/./node_modules/y-prosemirror/src/lib.js\");\n/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keys.js */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/keys.js\");\n/* harmony import */ var lib0_math__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lib0/math */ \"(ssr)/./node_modules/lib0/math.js\");\n\n\n // eslint-disable-line\n // eslint-disable-line\n // eslint-disable-line\n\n\n\n\n\n/**\n * Default generator for a cursor element\n *\n * @param {any} user user data\n * @return {HTMLElement}\n */\nconst defaultCursorBuilder = user => {\n  const cursor = document.createElement('span')\n  cursor.classList.add('ProseMirror-yjs-cursor')\n  cursor.setAttribute('style', `border-color: ${user.color}`)\n  const userDiv = document.createElement('div')\n  userDiv.setAttribute('style', `background-color: ${user.color}`)\n  userDiv.insertBefore(document.createTextNode(user.name), null)\n  const nonbreakingSpace1 = document.createTextNode('\\u2060')\n  const nonbreakingSpace2 = document.createTextNode('\\u2060')\n  cursor.insertBefore(nonbreakingSpace1, null)\n  cursor.insertBefore(userDiv, null)\n  cursor.insertBefore(nonbreakingSpace2, null)\n  return cursor\n}\n\n/**\n * Default generator for the selection attributes\n *\n * @param {any} user user data\n * @return {import('prosemirror-view').DecorationAttrs}\n */\nconst defaultSelectionBuilder = user => {\n  return {\n    style: `background-color: ${user.color}70`,\n    class: `ProseMirror-yjs-selection`\n  }\n}\n\nconst rxValidColor = /^#[0-9a-fA-F]{6}$/\n\n/**\n * @param {any} state\n * @param {Awareness} awareness\n * @return {any} DecorationSet\n */\nconst createDecorations = (state, awareness, createCursor, createSelection) => {\n  const ystate = _keys_js__WEBPACK_IMPORTED_MODULE_1__.ySyncPluginKey.getState(state)\n  const y = ystate.doc\n  const decorations = []\n  if (ystate.snapshot != null || ystate.prevSnapshot != null || ystate.binding === null) {\n    // do not render cursors while snapshot is active\n    return prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.DecorationSet.create(state.doc, [])\n  }\n  awareness.getStates().forEach((aw, clientId) => {\n    if (clientId === y.clientID) {\n      return\n    }\n    if (aw.cursor != null) {\n      const user = aw.user || {}\n      if (user.color == null) {\n        user.color = '#ffa500'\n      } else if (!rxValidColor.test(user.color)) {\n        // We only support 6-digit RGB colors in y-prosemirror\n        console.warn('A user uses an unsupported color format', user)\n      }\n      if (user.name == null) {\n        user.name = `User: ${clientId}`\n      }\n      let anchor = (0,_lib_js__WEBPACK_IMPORTED_MODULE_3__.relativePositionToAbsolutePosition)(y, ystate.type, yjs__WEBPACK_IMPORTED_MODULE_4__.createRelativePositionFromJSON(aw.cursor.anchor), ystate.binding.mapping)\n      let head = (0,_lib_js__WEBPACK_IMPORTED_MODULE_3__.relativePositionToAbsolutePosition)(y, ystate.type, yjs__WEBPACK_IMPORTED_MODULE_4__.createRelativePositionFromJSON(aw.cursor.head), ystate.binding.mapping)\n      if (anchor !== null && head !== null) {\n        const maxsize = lib0_math__WEBPACK_IMPORTED_MODULE_5__.max(state.doc.content.size - 1, 0)\n        anchor = lib0_math__WEBPACK_IMPORTED_MODULE_5__.min(anchor, maxsize)\n        head = lib0_math__WEBPACK_IMPORTED_MODULE_5__.min(head, maxsize)\n        decorations.push(prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.widget(head, () => createCursor(user), { key: clientId + '', side: 10 }))\n        const from = lib0_math__WEBPACK_IMPORTED_MODULE_5__.min(anchor, head)\n        const to = lib0_math__WEBPACK_IMPORTED_MODULE_5__.max(anchor, head)\n        decorations.push(prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.inline(from, to, createSelection(user), { inclusiveEnd: true, inclusiveStart: false }))\n      }\n    }\n  })\n  return prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.DecorationSet.create(state.doc, decorations)\n}\n\n/**\n * A prosemirror plugin that listens to awareness information on Yjs.\n * This requires that a `prosemirrorPlugin` is also bound to the prosemirror.\n *\n * @public\n * @param {Awareness} awareness\n * @param {object} [opts]\n * @param {function(any):HTMLElement} [opts.cursorBuilder]\n * @param {function(any):import('prosemirror-view').DecorationAttrs} [opts.selectionBuilder]\n * @param {function(any):any} [opts.getSelection]\n * @param {string} [cursorStateField] By default all editor bindings use the awareness 'cursor' field to propagate cursor information.\n * @return {any}\n */\nconst yCursorPlugin = (awareness, { cursorBuilder = defaultCursorBuilder, selectionBuilder = defaultSelectionBuilder, getSelection = state => state.selection } = {}, cursorStateField = 'cursor') => new prosemirror_state__WEBPACK_IMPORTED_MODULE_6__.Plugin({\n  key: _keys_js__WEBPACK_IMPORTED_MODULE_1__.yCursorPluginKey,\n  state: {\n    init (_, state) {\n      return createDecorations(state, awareness, cursorBuilder, selectionBuilder)\n    },\n    apply (tr, prevState, oldState, newState) {\n      const ystate = _keys_js__WEBPACK_IMPORTED_MODULE_1__.ySyncPluginKey.getState(newState)\n      const yCursorState = tr.getMeta(_keys_js__WEBPACK_IMPORTED_MODULE_1__.yCursorPluginKey)\n      if ((ystate && ystate.isChangeOrigin) || (yCursorState && yCursorState.awarenessUpdated)) {\n        return createDecorations(newState, awareness, cursorBuilder, selectionBuilder)\n      }\n      return prevState.map(tr.mapping, tr.doc)\n    }\n  },\n  props: {\n    decorations: state => {\n      return _keys_js__WEBPACK_IMPORTED_MODULE_1__.yCursorPluginKey.getState(state)\n    }\n  },\n  view: view => {\n    const awarenessListener = () => {\n      // @ts-ignore\n      if (view.docView) {\n        (0,_lib_js__WEBPACK_IMPORTED_MODULE_3__.setMeta)(view, _keys_js__WEBPACK_IMPORTED_MODULE_1__.yCursorPluginKey, { awarenessUpdated: true })\n      }\n    }\n    const updateCursorInfo = () => {\n      const ystate = _keys_js__WEBPACK_IMPORTED_MODULE_1__.ySyncPluginKey.getState(view.state)\n      // @note We make implicit checks when checking for the cursor property\n      const current = awareness.getLocalState() || {}\n      if (ystate.binding == null) {\n        return\n      }\n      if (view.hasFocus()) {\n        const selection = getSelection(view.state)\n        /**\n         * @type {Y.RelativePosition}\n         */\n        const anchor = (0,_lib_js__WEBPACK_IMPORTED_MODULE_3__.absolutePositionToRelativePosition)(selection.anchor, ystate.type, ystate.binding.mapping)\n        /**\n         * @type {Y.RelativePosition}\n         */\n        const head = (0,_lib_js__WEBPACK_IMPORTED_MODULE_3__.absolutePositionToRelativePosition)(selection.head, ystate.type, ystate.binding.mapping)\n        if (current.cursor == null || !yjs__WEBPACK_IMPORTED_MODULE_4__.compareRelativePositions(yjs__WEBPACK_IMPORTED_MODULE_4__.createRelativePositionFromJSON(current.cursor.anchor), anchor) || !yjs__WEBPACK_IMPORTED_MODULE_4__.compareRelativePositions(yjs__WEBPACK_IMPORTED_MODULE_4__.createRelativePositionFromJSON(current.cursor.head), head)) {\n          awareness.setLocalStateField(cursorStateField, {\n            anchor, head\n          })\n        }\n      } else if (current.cursor != null && (0,_lib_js__WEBPACK_IMPORTED_MODULE_3__.relativePositionToAbsolutePosition)(ystate.doc, ystate.type, yjs__WEBPACK_IMPORTED_MODULE_4__.createRelativePositionFromJSON(current.cursor.anchor), ystate.binding.mapping) !== null) {\n        // delete cursor information if current cursor information is owned by this editor binding\n        awareness.setLocalStateField(cursorStateField, null)\n      }\n    }\n    awareness.on('change', awarenessListener)\n    view.dom.addEventListener('focusin', updateCursorInfo)\n    view.dom.addEventListener('focusout', updateCursorInfo)\n    return {\n      update: updateCursorInfo,\n      destroy: () => {\n        view.dom.removeEventListener('focusin', updateCursorInfo)\n        view.dom.removeEventListener('focusout', updateCursorInfo)\n        awareness.off('change', awarenessListener)\n        awareness.setLocalStateField(cursorStateField, null)\n      }\n    }\n  }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveS1wcm9zZW1pcnJvci9zcmMvcGx1Z2lucy9jdXJzb3ItcGx1Z2luLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUN3QjtBQUNvQztBQUNsQjtBQUNPO0FBQzBEO0FBQy9DOztBQUUzQjs7QUFFakM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQTtBQUNBLGdEQUFnRCxXQUFXO0FBQzNEO0FBQ0EscURBQXFELFdBQVc7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBLGdDQUFnQyxXQUFXO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsRUFBRTs7QUFFdEM7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxXQUFXO0FBQ3RCLFlBQVksS0FBSztBQUNqQjtBQUNPO0FBQ1AsaUJBQWlCLG9EQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyREFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBLG1CQUFtQiwyRUFBa0MsaUJBQWlCLCtEQUFnQztBQUN0RyxpQkFBaUIsMkVBQWtDLGlCQUFpQiwrREFBZ0M7QUFDcEc7QUFDQSx3QkFBd0IsMENBQVE7QUFDaEMsaUJBQWlCLDBDQUFRO0FBQ3pCLGVBQWUsMENBQVE7QUFDdkIseUJBQXlCLHdEQUFVLDBDQUEwQyw4QkFBOEI7QUFDM0cscUJBQXFCLDBDQUFRO0FBQzdCLG1CQUFtQiwwQ0FBUTtBQUMzQix5QkFBeUIsd0RBQVUsMkNBQTJDLDJDQUEyQztBQUN6SDtBQUNBO0FBQ0EsR0FBRztBQUNILFNBQVMsMkRBQWE7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLFFBQVE7QUFDbkIsV0FBVywyQkFBMkI7QUFDdEMsV0FBVywwREFBMEQ7QUFDckUsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNPLG9DQUFvQyw0SEFBNEgsSUFBSSxzQ0FBc0MscURBQU07QUFDdk4sT0FBTyxzREFBZ0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EscUJBQXFCLG9EQUFjO0FBQ25DLHNDQUFzQyxzREFBZ0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsYUFBYSxzREFBZ0I7QUFDN0I7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdEQUFPLE9BQU8sc0RBQWdCLElBQUksd0JBQXdCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvREFBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsdUJBQXVCLDJFQUFrQztBQUN6RDtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLHFCQUFxQiwyRUFBa0M7QUFDdkQsdUNBQXVDLHlEQUEwQixDQUFDLCtEQUFnQyxxQ0FBcUMseURBQTBCLENBQUMsK0RBQWdDO0FBQ2xNO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxRQUFRLG1DQUFtQywyRUFBa0MsMEJBQTBCLCtEQUFnQztBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3plbmJvYXJkLy4vbm9kZV9tb2R1bGVzL3ktcHJvc2VtaXJyb3Ivc3JjL3BsdWdpbnMvY3Vyc29yLXBsdWdpbi5qcz9hNDRiIl0sInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0ICogYXMgWSBmcm9tICd5anMnXG5pbXBvcnQgeyBEZWNvcmF0aW9uLCBEZWNvcmF0aW9uU2V0IH0gZnJvbSAncHJvc2VtaXJyb3ItdmlldycgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbmltcG9ydCB7IEF3YXJlbmVzcyB9IGZyb20gJ3ktcHJvdG9jb2xzL2F3YXJlbmVzcycgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuaW1wb3J0IHsgYWJzb2x1dGVQb3NpdGlvblRvUmVsYXRpdmVQb3NpdGlvbiwgcmVsYXRpdmVQb3NpdGlvblRvQWJzb2x1dGVQb3NpdGlvbiwgc2V0TWV0YSB9IGZyb20gJy4uL2xpYi5qcydcbmltcG9ydCB7IHlDdXJzb3JQbHVnaW5LZXksIHlTeW5jUGx1Z2luS2V5IH0gZnJvbSAnLi9rZXlzLmpzJ1xuXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJ2xpYjAvbWF0aCdcblxuLyoqXG4gKiBEZWZhdWx0IGdlbmVyYXRvciBmb3IgYSBjdXJzb3IgZWxlbWVudFxuICpcbiAqIEBwYXJhbSB7YW55fSB1c2VyIHVzZXIgZGF0YVxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0Q3Vyc29yQnVpbGRlciA9IHVzZXIgPT4ge1xuICBjb25zdCBjdXJzb3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJylcbiAgY3Vyc29yLmNsYXNzTGlzdC5hZGQoJ1Byb3NlTWlycm9yLXlqcy1jdXJzb3InKVxuICBjdXJzb3Iuc2V0QXR0cmlidXRlKCdzdHlsZScsIGBib3JkZXItY29sb3I6ICR7dXNlci5jb2xvcn1gKVxuICBjb25zdCB1c2VyRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgdXNlckRpdi5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgYGJhY2tncm91bmQtY29sb3I6ICR7dXNlci5jb2xvcn1gKVxuICB1c2VyRGl2Lmluc2VydEJlZm9yZShkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh1c2VyLm5hbWUpLCBudWxsKVxuICBjb25zdCBub25icmVha2luZ1NwYWNlMSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdcXHUyMDYwJylcbiAgY29uc3Qgbm9uYnJlYWtpbmdTcGFjZTIgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnXFx1MjA2MCcpXG4gIGN1cnNvci5pbnNlcnRCZWZvcmUobm9uYnJlYWtpbmdTcGFjZTEsIG51bGwpXG4gIGN1cnNvci5pbnNlcnRCZWZvcmUodXNlckRpdiwgbnVsbClcbiAgY3Vyc29yLmluc2VydEJlZm9yZShub25icmVha2luZ1NwYWNlMiwgbnVsbClcbiAgcmV0dXJuIGN1cnNvclxufVxuXG4vKipcbiAqIERlZmF1bHQgZ2VuZXJhdG9yIGZvciB0aGUgc2VsZWN0aW9uIGF0dHJpYnV0ZXNcbiAqXG4gKiBAcGFyYW0ge2FueX0gdXNlciB1c2VyIGRhdGFcbiAqIEByZXR1cm4ge2ltcG9ydCgncHJvc2VtaXJyb3ItdmlldycpLkRlY29yYXRpb25BdHRyc31cbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRTZWxlY3Rpb25CdWlsZGVyID0gdXNlciA9PiB7XG4gIHJldHVybiB7XG4gICAgc3R5bGU6IGBiYWNrZ3JvdW5kLWNvbG9yOiAke3VzZXIuY29sb3J9NzBgLFxuICAgIGNsYXNzOiBgUHJvc2VNaXJyb3IteWpzLXNlbGVjdGlvbmBcbiAgfVxufVxuXG5jb25zdCByeFZhbGlkQ29sb3IgPSAvXiNbMC05YS1mQS1GXXs2fSQvXG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHN0YXRlXG4gKiBAcGFyYW0ge0F3YXJlbmVzc30gYXdhcmVuZXNzXG4gKiBAcmV0dXJuIHthbnl9IERlY29yYXRpb25TZXRcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZURlY29yYXRpb25zID0gKHN0YXRlLCBhd2FyZW5lc3MsIGNyZWF0ZUN1cnNvciwgY3JlYXRlU2VsZWN0aW9uKSA9PiB7XG4gIGNvbnN0IHlzdGF0ZSA9IHlTeW5jUGx1Z2luS2V5LmdldFN0YXRlKHN0YXRlKVxuICBjb25zdCB5ID0geXN0YXRlLmRvY1xuICBjb25zdCBkZWNvcmF0aW9ucyA9IFtdXG4gIGlmICh5c3RhdGUuc25hcHNob3QgIT0gbnVsbCB8fCB5c3RhdGUucHJldlNuYXBzaG90ICE9IG51bGwgfHwgeXN0YXRlLmJpbmRpbmcgPT09IG51bGwpIHtcbiAgICAvLyBkbyBub3QgcmVuZGVyIGN1cnNvcnMgd2hpbGUgc25hcHNob3QgaXMgYWN0aXZlXG4gICAgcmV0dXJuIERlY29yYXRpb25TZXQuY3JlYXRlKHN0YXRlLmRvYywgW10pXG4gIH1cbiAgYXdhcmVuZXNzLmdldFN0YXRlcygpLmZvckVhY2goKGF3LCBjbGllbnRJZCkgPT4ge1xuICAgIGlmIChjbGllbnRJZCA9PT0geS5jbGllbnRJRCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmIChhdy5jdXJzb3IgIT0gbnVsbCkge1xuICAgICAgY29uc3QgdXNlciA9IGF3LnVzZXIgfHwge31cbiAgICAgIGlmICh1c2VyLmNvbG9yID09IG51bGwpIHtcbiAgICAgICAgdXNlci5jb2xvciA9ICcjZmZhNTAwJ1xuICAgICAgfSBlbHNlIGlmICghcnhWYWxpZENvbG9yLnRlc3QodXNlci5jb2xvcikpIHtcbiAgICAgICAgLy8gV2Ugb25seSBzdXBwb3J0IDYtZGlnaXQgUkdCIGNvbG9ycyBpbiB5LXByb3NlbWlycm9yXG4gICAgICAgIGNvbnNvbGUud2FybignQSB1c2VyIHVzZXMgYW4gdW5zdXBwb3J0ZWQgY29sb3IgZm9ybWF0JywgdXNlcilcbiAgICAgIH1cbiAgICAgIGlmICh1c2VyLm5hbWUgPT0gbnVsbCkge1xuICAgICAgICB1c2VyLm5hbWUgPSBgVXNlcjogJHtjbGllbnRJZH1gXG4gICAgICB9XG4gICAgICBsZXQgYW5jaG9yID0gcmVsYXRpdmVQb3NpdGlvblRvQWJzb2x1dGVQb3NpdGlvbih5LCB5c3RhdGUudHlwZSwgWS5jcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbUpTT04oYXcuY3Vyc29yLmFuY2hvciksIHlzdGF0ZS5iaW5kaW5nLm1hcHBpbmcpXG4gICAgICBsZXQgaGVhZCA9IHJlbGF0aXZlUG9zaXRpb25Ub0Fic29sdXRlUG9zaXRpb24oeSwgeXN0YXRlLnR5cGUsIFkuY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21KU09OKGF3LmN1cnNvci5oZWFkKSwgeXN0YXRlLmJpbmRpbmcubWFwcGluZylcbiAgICAgIGlmIChhbmNob3IgIT09IG51bGwgJiYgaGVhZCAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBtYXhzaXplID0gbWF0aC5tYXgoc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZSAtIDEsIDApXG4gICAgICAgIGFuY2hvciA9IG1hdGgubWluKGFuY2hvciwgbWF4c2l6ZSlcbiAgICAgICAgaGVhZCA9IG1hdGgubWluKGhlYWQsIG1heHNpemUpXG4gICAgICAgIGRlY29yYXRpb25zLnB1c2goRGVjb3JhdGlvbi53aWRnZXQoaGVhZCwgKCkgPT4gY3JlYXRlQ3Vyc29yKHVzZXIpLCB7IGtleTogY2xpZW50SWQgKyAnJywgc2lkZTogMTAgfSkpXG4gICAgICAgIGNvbnN0IGZyb20gPSBtYXRoLm1pbihhbmNob3IsIGhlYWQpXG4gICAgICAgIGNvbnN0IHRvID0gbWF0aC5tYXgoYW5jaG9yLCBoZWFkKVxuICAgICAgICBkZWNvcmF0aW9ucy5wdXNoKERlY29yYXRpb24uaW5saW5lKGZyb20sIHRvLCBjcmVhdGVTZWxlY3Rpb24odXNlciksIHsgaW5jbHVzaXZlRW5kOiB0cnVlLCBpbmNsdXNpdmVTdGFydDogZmFsc2UgfSkpXG4gICAgICB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gRGVjb3JhdGlvblNldC5jcmVhdGUoc3RhdGUuZG9jLCBkZWNvcmF0aW9ucylcbn1cblxuLyoqXG4gKiBBIHByb3NlbWlycm9yIHBsdWdpbiB0aGF0IGxpc3RlbnMgdG8gYXdhcmVuZXNzIGluZm9ybWF0aW9uIG9uIFlqcy5cbiAqIFRoaXMgcmVxdWlyZXMgdGhhdCBhIGBwcm9zZW1pcnJvclBsdWdpbmAgaXMgYWxzbyBib3VuZCB0byB0aGUgcHJvc2VtaXJyb3IuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtBd2FyZW5lc3N9IGF3YXJlbmVzc1xuICogQHBhcmFtIHtvYmplY3R9IFtvcHRzXVxuICogQHBhcmFtIHtmdW5jdGlvbihhbnkpOkhUTUxFbGVtZW50fSBbb3B0cy5jdXJzb3JCdWlsZGVyXVxuICogQHBhcmFtIHtmdW5jdGlvbihhbnkpOmltcG9ydCgncHJvc2VtaXJyb3ItdmlldycpLkRlY29yYXRpb25BdHRyc30gW29wdHMuc2VsZWN0aW9uQnVpbGRlcl1cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oYW55KTphbnl9IFtvcHRzLmdldFNlbGVjdGlvbl1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yU3RhdGVGaWVsZF0gQnkgZGVmYXVsdCBhbGwgZWRpdG9yIGJpbmRpbmdzIHVzZSB0aGUgYXdhcmVuZXNzICdjdXJzb3InIGZpZWxkIHRvIHByb3BhZ2F0ZSBjdXJzb3IgaW5mb3JtYXRpb24uXG4gKiBAcmV0dXJuIHthbnl9XG4gKi9cbmV4cG9ydCBjb25zdCB5Q3Vyc29yUGx1Z2luID0gKGF3YXJlbmVzcywgeyBjdXJzb3JCdWlsZGVyID0gZGVmYXVsdEN1cnNvckJ1aWxkZXIsIHNlbGVjdGlvbkJ1aWxkZXIgPSBkZWZhdWx0U2VsZWN0aW9uQnVpbGRlciwgZ2V0U2VsZWN0aW9uID0gc3RhdGUgPT4gc3RhdGUuc2VsZWN0aW9uIH0gPSB7fSwgY3Vyc29yU3RhdGVGaWVsZCA9ICdjdXJzb3InKSA9PiBuZXcgUGx1Z2luKHtcbiAga2V5OiB5Q3Vyc29yUGx1Z2luS2V5LFxuICBzdGF0ZToge1xuICAgIGluaXQgKF8sIHN0YXRlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRGVjb3JhdGlvbnMoc3RhdGUsIGF3YXJlbmVzcywgY3Vyc29yQnVpbGRlciwgc2VsZWN0aW9uQnVpbGRlcilcbiAgICB9LFxuICAgIGFwcGx5ICh0ciwgcHJldlN0YXRlLCBvbGRTdGF0ZSwgbmV3U3RhdGUpIHtcbiAgICAgIGNvbnN0IHlzdGF0ZSA9IHlTeW5jUGx1Z2luS2V5LmdldFN0YXRlKG5ld1N0YXRlKVxuICAgICAgY29uc3QgeUN1cnNvclN0YXRlID0gdHIuZ2V0TWV0YSh5Q3Vyc29yUGx1Z2luS2V5KVxuICAgICAgaWYgKCh5c3RhdGUgJiYgeXN0YXRlLmlzQ2hhbmdlT3JpZ2luKSB8fCAoeUN1cnNvclN0YXRlICYmIHlDdXJzb3JTdGF0ZS5hd2FyZW5lc3NVcGRhdGVkKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRGVjb3JhdGlvbnMobmV3U3RhdGUsIGF3YXJlbmVzcywgY3Vyc29yQnVpbGRlciwgc2VsZWN0aW9uQnVpbGRlcilcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcmV2U3RhdGUubWFwKHRyLm1hcHBpbmcsIHRyLmRvYylcbiAgICB9XG4gIH0sXG4gIHByb3BzOiB7XG4gICAgZGVjb3JhdGlvbnM6IHN0YXRlID0+IHtcbiAgICAgIHJldHVybiB5Q3Vyc29yUGx1Z2luS2V5LmdldFN0YXRlKHN0YXRlKVxuICAgIH1cbiAgfSxcbiAgdmlldzogdmlldyA9PiB7XG4gICAgY29uc3QgYXdhcmVuZXNzTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBpZiAodmlldy5kb2NWaWV3KSB7XG4gICAgICAgIHNldE1ldGEodmlldywgeUN1cnNvclBsdWdpbktleSwgeyBhd2FyZW5lc3NVcGRhdGVkOiB0cnVlIH0pXG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZUN1cnNvckluZm8gPSAoKSA9PiB7XG4gICAgICBjb25zdCB5c3RhdGUgPSB5U3luY1BsdWdpbktleS5nZXRTdGF0ZSh2aWV3LnN0YXRlKVxuICAgICAgLy8gQG5vdGUgV2UgbWFrZSBpbXBsaWNpdCBjaGVja3Mgd2hlbiBjaGVja2luZyBmb3IgdGhlIGN1cnNvciBwcm9wZXJ0eVxuICAgICAgY29uc3QgY3VycmVudCA9IGF3YXJlbmVzcy5nZXRMb2NhbFN0YXRlKCkgfHwge31cbiAgICAgIGlmICh5c3RhdGUuYmluZGluZyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgaWYgKHZpZXcuaGFzRm9jdXMoKSkge1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBnZXRTZWxlY3Rpb24odmlldy5zdGF0ZSlcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtZLlJlbGF0aXZlUG9zaXRpb259XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBhbmNob3IgPSBhYnNvbHV0ZVBvc2l0aW9uVG9SZWxhdGl2ZVBvc2l0aW9uKHNlbGVjdGlvbi5hbmNob3IsIHlzdGF0ZS50eXBlLCB5c3RhdGUuYmluZGluZy5tYXBwaW5nKVxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge1kuUmVsYXRpdmVQb3NpdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGhlYWQgPSBhYnNvbHV0ZVBvc2l0aW9uVG9SZWxhdGl2ZVBvc2l0aW9uKHNlbGVjdGlvbi5oZWFkLCB5c3RhdGUudHlwZSwgeXN0YXRlLmJpbmRpbmcubWFwcGluZylcbiAgICAgICAgaWYgKGN1cnJlbnQuY3Vyc29yID09IG51bGwgfHwgIVkuY29tcGFyZVJlbGF0aXZlUG9zaXRpb25zKFkuY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21KU09OKGN1cnJlbnQuY3Vyc29yLmFuY2hvciksIGFuY2hvcikgfHwgIVkuY29tcGFyZVJlbGF0aXZlUG9zaXRpb25zKFkuY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21KU09OKGN1cnJlbnQuY3Vyc29yLmhlYWQpLCBoZWFkKSkge1xuICAgICAgICAgIGF3YXJlbmVzcy5zZXRMb2NhbFN0YXRlRmllbGQoY3Vyc29yU3RhdGVGaWVsZCwge1xuICAgICAgICAgICAgYW5jaG9yLCBoZWFkXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjdXJyZW50LmN1cnNvciAhPSBudWxsICYmIHJlbGF0aXZlUG9zaXRpb25Ub0Fic29sdXRlUG9zaXRpb24oeXN0YXRlLmRvYywgeXN0YXRlLnR5cGUsIFkuY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21KU09OKGN1cnJlbnQuY3Vyc29yLmFuY2hvciksIHlzdGF0ZS5iaW5kaW5nLm1hcHBpbmcpICE9PSBudWxsKSB7XG4gICAgICAgIC8vIGRlbGV0ZSBjdXJzb3IgaW5mb3JtYXRpb24gaWYgY3VycmVudCBjdXJzb3IgaW5mb3JtYXRpb24gaXMgb3duZWQgYnkgdGhpcyBlZGl0b3IgYmluZGluZ1xuICAgICAgICBhd2FyZW5lc3Muc2V0TG9jYWxTdGF0ZUZpZWxkKGN1cnNvclN0YXRlRmllbGQsIG51bGwpXG4gICAgICB9XG4gICAgfVxuICAgIGF3YXJlbmVzcy5vbignY2hhbmdlJywgYXdhcmVuZXNzTGlzdGVuZXIpXG4gICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIHVwZGF0ZUN1cnNvckluZm8pXG4gICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCB1cGRhdGVDdXJzb3JJbmZvKVxuICAgIHJldHVybiB7XG4gICAgICB1cGRhdGU6IHVwZGF0ZUN1cnNvckluZm8sXG4gICAgICBkZXN0cm95OiAoKSA9PiB7XG4gICAgICAgIHZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCB1cGRhdGVDdXJzb3JJbmZvKVxuICAgICAgICB2aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIHVwZGF0ZUN1cnNvckluZm8pXG4gICAgICAgIGF3YXJlbmVzcy5vZmYoJ2NoYW5nZScsIGF3YXJlbmVzc0xpc3RlbmVyKVxuICAgICAgICBhd2FyZW5lc3Muc2V0TG9jYWxTdGF0ZUZpZWxkKGN1cnNvclN0YXRlRmllbGQsIG51bGwpXG4gICAgICB9XG4gICAgfVxuICB9XG59KVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/y-prosemirror/src/plugins/cursor-plugin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/y-prosemirror/src/plugins/keys.js":
/*!********************************************************!*\
  !*** ./node_modules/y-prosemirror/src/plugins/keys.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   yCursorPluginKey: () => (/* binding */ yCursorPluginKey),\n/* harmony export */   ySyncPluginKey: () => (/* binding */ ySyncPluginKey),\n/* harmony export */   yUndoPluginKey: () => (/* binding */ yUndoPluginKey)\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n\n // eslint-disable-line\n\n/**\n * The unique prosemirror plugin key for syncPlugin\n *\n * @public\n */\nconst ySyncPluginKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('y-sync')\n\n/**\n * The unique prosemirror plugin key for undoPlugin\n *\n * @public\n */\nconst yUndoPluginKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('y-undo')\n\n/**\n * The unique prosemirror plugin key for cursorPlugin\n *\n * @public\n */\nconst yCursorPluginKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('yjs-cursor')\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveS1wcm9zZW1pcnJvci9zcmMvcGx1Z2lucy9rZXlzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQzZDOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMkJBQTJCLHdEQUFTOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMkJBQTJCLHdEQUFTOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sNkJBQTZCLHdEQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemVuYm9hcmQvLi9ub2RlX21vZHVsZXMveS1wcm9zZW1pcnJvci9zcmMvcGx1Z2lucy9rZXlzLmpzP2MzZjciXSwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgeyBQbHVnaW5LZXkgfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZScgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4vKipcbiAqIFRoZSB1bmlxdWUgcHJvc2VtaXJyb3IgcGx1Z2luIGtleSBmb3Igc3luY1BsdWdpblxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHlTeW5jUGx1Z2luS2V5ID0gbmV3IFBsdWdpbktleSgneS1zeW5jJylcblxuLyoqXG4gKiBUaGUgdW5pcXVlIHByb3NlbWlycm9yIHBsdWdpbiBrZXkgZm9yIHVuZG9QbHVnaW5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCB5VW5kb1BsdWdpbktleSA9IG5ldyBQbHVnaW5LZXkoJ3ktdW5kbycpXG5cbi8qKlxuICogVGhlIHVuaXF1ZSBwcm9zZW1pcnJvciBwbHVnaW4ga2V5IGZvciBjdXJzb3JQbHVnaW5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCB5Q3Vyc29yUGx1Z2luS2V5ID0gbmV3IFBsdWdpbktleSgneWpzLWN1cnNvcicpXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/y-prosemirror/src/plugins/keys.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/y-prosemirror/src/plugins/sync-plugin.js":
/*!***************************************************************!*\
  !*** ./node_modules/y-prosemirror/src/plugins/sync-plugin.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ProsemirrorBinding: () => (/* binding */ ProsemirrorBinding),\n/* harmony export */   getRelativeSelection: () => (/* binding */ getRelativeSelection),\n/* harmony export */   isVisible: () => (/* binding */ isVisible),\n/* harmony export */   updateYFragment: () => (/* binding */ updateYFragment),\n/* harmony export */   ySyncPlugin: () => (/* binding */ ySyncPlugin)\n/* harmony export */ });\n/* harmony import */ var lib0_mutex__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lib0/mutex */ \"(ssr)/./node_modules/lib0/mutex.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var lib0_math__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! lib0/math */ \"(ssr)/./node_modules/lib0/math.js\");\n/* harmony import */ var lib0_object__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! lib0/object */ \"(ssr)/./node_modules/lib0/object.js\");\n/* harmony import */ var lib0_set__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/set */ \"(ssr)/./node_modules/lib0/set.js\");\n/* harmony import */ var lib0_diff__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! lib0/diff */ \"(ssr)/./node_modules/lib0/diff.js\");\n/* harmony import */ var lib0_error__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lib0/error */ \"(ssr)/./node_modules/lib0/error.js\");\n/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./keys.js */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/keys.js\");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! yjs */ \"(ssr)/./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var _lib_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../lib.js */ \"(ssr)/./node_modules/y-prosemirror/src/lib.js\");\n/* harmony import */ var lib0_random__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/random */ \"(ssr)/./node_modules/lib0/random.js\");\n/* harmony import */ var lib0_environment__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lib0/environment */ \"(ssr)/./node_modules/lib0/environment.js\");\n/* harmony import */ var lib0_dom__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lib0/dom */ \"(ssr)/./node_modules/lib0/dom.js\");\n/* harmony import */ var lib0_eventloop__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lib0/eventloop */ \"(ssr)/./node_modules/lib0/eventloop.js\");\n/**\n * @module bindings/prosemirror\n */\n\n\n\n // eslint-disable-line\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @param {Y.Item} item\n * @param {Y.Snapshot} [snapshot]\n */\nconst isVisible = (item, snapshot) => snapshot === undefined ? !item.deleted : (snapshot.sv.has(item.id.client) && /** @type {number} */ (snapshot.sv.get(item.id.client)) > item.id.clock && !yjs__WEBPACK_IMPORTED_MODULE_0__.isDeleted(snapshot.ds, item.id))\n\n/**\n * Either a node if type is YXmlElement or an Array of text nodes if YXmlText\n * @typedef {Map<Y.AbstractType<any>, PModel.Node | Array<PModel.Node>>} ProsemirrorMapping\n */\n\n/**\n * @typedef {Object} ColorDef\n * @property {string} ColorDef.light\n * @property {string} ColorDef.dark\n */\n\n/**\n * @typedef {Object} YSyncOpts\n * @property {Array<ColorDef>} [YSyncOpts.colors]\n * @property {Map<string,ColorDef>} [YSyncOpts.colorMapping]\n * @property {Y.PermanentUserData|null} [YSyncOpts.permanentUserData]\n * @property {function} [YSyncOpts.onFirstRender] Fired when the content from Yjs is initially rendered to ProseMirror\n */\n\n/**\n * @type {Array<ColorDef>}\n */\nconst defaultColors = [{ light: '#ecd44433', dark: '#ecd444' }]\n\n/**\n * @param {Map<string,ColorDef>} colorMapping\n * @param {Array<ColorDef>} colors\n * @param {string} user\n * @return {ColorDef}\n */\nconst getUserColor = (colorMapping, colors, user) => {\n  // @todo do not hit the same color twice if possible\n  if (!colorMapping.has(user)) {\n    if (colorMapping.size < colors.length) {\n      const usedColors = lib0_set__WEBPACK_IMPORTED_MODULE_1__.create()\n      colorMapping.forEach(color => usedColors.add(color))\n      colors = colors.filter(color => !usedColors.has(color))\n    }\n    colorMapping.set(user, lib0_random__WEBPACK_IMPORTED_MODULE_2__.oneOf(colors))\n  }\n  return /** @type {ColorDef} */ (colorMapping.get(user))\n}\n\n/**\n * This plugin listens to changes in prosemirror view and keeps yXmlState and view in sync.\n *\n * This plugin also keeps references to the type and the shared document so other plugins can access it.\n * @param {Y.XmlFragment} yXmlFragment\n * @param {YSyncOpts} opts\n * @return {any} Returns a prosemirror plugin that binds to this type\n */\nconst ySyncPlugin = (yXmlFragment, {\n  colors = defaultColors,\n  colorMapping = new Map(),\n  permanentUserData = null,\n  onFirstRender = () => {}\n} = {}) => {\n  let changedInitialContent = false\n  let rerenderTimeoutId\n  const plugin = new prosemirror_state__WEBPACK_IMPORTED_MODULE_3__.Plugin({\n    props: {\n      editable: (state) => {\n        const syncState = _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey.getState(state)\n        return syncState.snapshot == null && syncState.prevSnapshot == null\n      }\n    },\n    key: _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey,\n    state: {\n      init: (initargs, state) => {\n        return {\n          type: yXmlFragment,\n          doc: yXmlFragment.doc,\n          binding: null,\n          snapshot: null,\n          prevSnapshot: null,\n          isChangeOrigin: false,\n          colors,\n          colorMapping,\n          permanentUserData\n        }\n      },\n      apply: (tr, pluginState) => {\n        const change = tr.getMeta(_keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey)\n        if (change !== undefined) {\n          pluginState = Object.assign({}, pluginState)\n          for (const key in change) {\n            pluginState[key] = change[key]\n          }\n        }\n        // always set isChangeOrigin. If undefined, this is not change origin.\n        pluginState.isChangeOrigin = change !== undefined && !!change.isChangeOrigin\n        if (pluginState.binding !== null) {\n          if (change !== undefined && (change.snapshot != null || change.prevSnapshot != null)) {\n            // snapshot changed, rerender next\n            lib0_eventloop__WEBPACK_IMPORTED_MODULE_5__.timeout(0, () => {\n              if (pluginState.binding == null || pluginState.binding.isDestroyed) {\n                return\n              }\n              if (change.restore == null) {\n                pluginState.binding._renderSnapshot(change.snapshot, change.prevSnapshot, pluginState)\n              } else {\n                pluginState.binding._renderSnapshot(change.snapshot, change.snapshot, pluginState)\n                // reset to current prosemirror state\n                delete pluginState.restore\n                delete pluginState.snapshot\n                delete pluginState.prevSnapshot\n                pluginState.binding._prosemirrorChanged(pluginState.binding.prosemirrorView.state.doc)\n              }\n            })\n          }\n        }\n        return pluginState\n      }\n    },\n    view: view => {\n      const binding = new ProsemirrorBinding(yXmlFragment, view)\n      if (rerenderTimeoutId != null) {\n        clearTimeout(rerenderTimeoutId)\n      }\n      // Make sure this is called in a separate context\n      rerenderTimeoutId = lib0_eventloop__WEBPACK_IMPORTED_MODULE_5__.timeout(0, () => {\n        binding._forceRerender()\n        view.dispatch(view.state.tr.setMeta(_keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey, { binding }))\n        onFirstRender()\n      })\n      return {\n        update: () => {\n          const pluginState = plugin.getState(view.state)\n          if (pluginState.snapshot == null && pluginState.prevSnapshot == null) {\n            if (changedInitialContent || view.state.doc.content.findDiffStart(view.state.doc.type.createAndFill().content) !== null) {\n              changedInitialContent = true\n              binding._prosemirrorChanged(view.state.doc)\n            }\n          }\n        },\n        destroy: () => {\n          clearTimeout(rerenderTimeoutId)\n          binding.destroy()\n        }\n      }\n    }\n  })\n  return plugin\n}\n\n/**\n * @param {any} tr\n * @param {any} relSel\n * @param {ProsemirrorBinding} binding\n */\nconst restoreRelativeSelection = (tr, relSel, binding) => {\n  if (relSel !== null && relSel.anchor !== null && relSel.head !== null) {\n    const anchor = (0,_lib_js__WEBPACK_IMPORTED_MODULE_6__.relativePositionToAbsolutePosition)(binding.doc, binding.type, relSel.anchor, binding.mapping)\n    const head = (0,_lib_js__WEBPACK_IMPORTED_MODULE_6__.relativePositionToAbsolutePosition)(binding.doc, binding.type, relSel.head, binding.mapping)\n    if (anchor !== null && head !== null) {\n      tr = tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_3__.TextSelection.create(tr.doc, anchor, head))\n    }\n  }\n}\n\nconst getRelativeSelection = (pmbinding, state) => ({\n  anchor: (0,_lib_js__WEBPACK_IMPORTED_MODULE_6__.absolutePositionToRelativePosition)(state.selection.anchor, pmbinding.type, pmbinding.mapping),\n  head: (0,_lib_js__WEBPACK_IMPORTED_MODULE_6__.absolutePositionToRelativePosition)(state.selection.head, pmbinding.type, pmbinding.mapping)\n})\n\n/**\n * Binding for prosemirror.\n *\n * @protected\n */\nclass ProsemirrorBinding {\n  /**\n   * @param {Y.XmlFragment} yXmlFragment The bind source\n   * @param {any} prosemirrorView The target binding\n   */\n  constructor (yXmlFragment, prosemirrorView) {\n    this.type = yXmlFragment\n    this.prosemirrorView = prosemirrorView\n    this.mux = (0,lib0_mutex__WEBPACK_IMPORTED_MODULE_7__.createMutex)()\n    this.isDestroyed = false\n    /**\n     * @type {ProsemirrorMapping}\n     */\n    this.mapping = new Map()\n    this._observeFunction = this._typeChanged.bind(this)\n    /**\n     * @type {Y.Doc}\n     */\n    // @ts-ignore\n    this.doc = yXmlFragment.doc\n    /**\n     * current selection as relative positions in the Yjs model\n     */\n    this.beforeTransactionSelection = null\n    this.beforeAllTransactions = () => {\n      if (this.beforeTransactionSelection === null) {\n        this.beforeTransactionSelection = getRelativeSelection(this, prosemirrorView.state)\n      }\n    }\n    this.afterAllTransactions = () => {\n      this.beforeTransactionSelection = null\n    }\n\n    this.doc.on('beforeAllTransactions', this.beforeAllTransactions)\n    this.doc.on('afterAllTransactions', this.afterAllTransactions)\n    yXmlFragment.observeDeep(this._observeFunction)\n\n    this._domSelectionInView = null\n  }\n\n  /**\n   * Create a transaction for changing the prosemirror state.\n   *\n   * @returns\n   */\n  get _tr () {\n    return this.prosemirrorView.state.tr.setMeta('addToHistory', false)\n  }\n\n  _isLocalCursorInView () {\n    if (!this.prosemirrorView.hasFocus()) return false\n    if (lib0_environment__WEBPACK_IMPORTED_MODULE_8__.isBrowser && this._domSelectionInView === null) {\n      // Calculate the domSelectionInView and clear by next tick after all events are finished\n      lib0_eventloop__WEBPACK_IMPORTED_MODULE_5__.timeout(0, () => {\n        this._domSelectionInView = null\n      })\n      this._domSelectionInView = this._isDomSelectionInView()\n    }\n    return this._domSelectionInView\n  }\n\n  _isDomSelectionInView () {\n    const selection = this.prosemirrorView._root.getSelection()\n\n    const range = this.prosemirrorView._root.createRange()\n    range.setStart(selection.anchorNode, selection.anchorOffset)\n    range.setEnd(selection.focusNode, selection.focusOffset)\n\n    // This is a workaround for an edgecase where getBoundingClientRect will\n    // return zero values if the selection is collapsed at the start of a newline\n    // see reference here: https://stackoverflow.com/a/59780954\n    const rects = range.getClientRects()\n    if (rects.length === 0) {\n      // probably buggy newline behavior, explicitly select the node contents\n      if (range.startContainer && range.collapsed) {\n        range.selectNodeContents(range.startContainer)\n      }\n    }\n\n    const bounding = range.getBoundingClientRect()\n    const documentElement = lib0_dom__WEBPACK_IMPORTED_MODULE_9__.doc.documentElement\n\n    return bounding.bottom >= 0 && bounding.right >= 0 &&\n      bounding.left <= (window.innerWidth || documentElement.clientWidth || 0) &&\n      bounding.top <= (window.innerHeight || documentElement.clientHeight || 0)\n  }\n\n  renderSnapshot (snapshot, prevSnapshot) {\n    if (!prevSnapshot) {\n      prevSnapshot = yjs__WEBPACK_IMPORTED_MODULE_0__.createSnapshot(yjs__WEBPACK_IMPORTED_MODULE_0__.createDeleteSet(), new Map())\n    }\n    this.prosemirrorView.dispatch(this._tr.setMeta(_keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey, { snapshot, prevSnapshot }))\n  }\n\n  unrenderSnapshot () {\n    this.mapping = new Map()\n    this.mux(() => {\n      const fragmentContent = this.type.toArray().map(t => createNodeFromYElement(/** @type {Y.XmlElement} */ (t), this.prosemirrorView.state.schema, this.mapping)).filter(n => n !== null)\n      // @ts-ignore\n      const tr = this._tr.replace(0, this.prosemirrorView.state.doc.content.size, new prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Slice(new prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Fragment(fragmentContent), 0, 0))\n      tr.setMeta(_keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey, { snapshot: null, prevSnapshot: null })\n      this.prosemirrorView.dispatch(tr)\n    })\n  }\n\n  _forceRerender () {\n    this.mapping = new Map()\n    this.mux(() => {\n      const fragmentContent = this.type.toArray().map(t => createNodeFromYElement(/** @type {Y.XmlElement} */ (t), this.prosemirrorView.state.schema, this.mapping)).filter(n => n !== null)\n      // @ts-ignore\n      const tr = this._tr.replace(0, this.prosemirrorView.state.doc.content.size, new prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Slice(new prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Fragment(fragmentContent), 0, 0))\n      this.prosemirrorView.dispatch(tr.setMeta(_keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey, { isChangeOrigin: true }))\n    })\n  }\n\n  /**\n   * @param {Y.Snapshot} snapshot\n   * @param {Y.Snapshot} prevSnapshot\n   * @param {Object} pluginState\n   */\n  _renderSnapshot (snapshot, prevSnapshot, pluginState) {\n    if (!snapshot) {\n      snapshot = yjs__WEBPACK_IMPORTED_MODULE_0__.snapshot(this.doc)\n    }\n    // clear mapping because we are going to rerender\n    this.mapping = new Map()\n    this.mux(() => {\n      this.doc.transact(transaction => {\n        // before rendering, we are going to sanitize ops and split deleted ops\n        // if they were deleted by seperate users.\n        const pud = pluginState.permanentUserData\n        if (pud) {\n          pud.dss.forEach(ds => {\n            yjs__WEBPACK_IMPORTED_MODULE_0__.iterateDeletedStructs(transaction, ds, item => {})\n          })\n        }\n        const computeYChange = (type, id) => {\n          const user = type === 'added' ? pud.getUserByClientId(id.client) : pud.getUserByDeletedId(id)\n          return {\n            user,\n            type,\n            color: getUserColor(pluginState.colorMapping, pluginState.colors, user)\n          }\n        }\n        // Create document fragment and render\n        const fragmentContent = yjs__WEBPACK_IMPORTED_MODULE_0__.typeListToArraySnapshot(this.type, new yjs__WEBPACK_IMPORTED_MODULE_0__.Snapshot(prevSnapshot.ds, snapshot.sv)).map(t => {\n          if (!t._item.deleted || isVisible(t._item, snapshot) || isVisible(t._item, prevSnapshot)) {\n            return createNodeFromYElement(t, this.prosemirrorView.state.schema, new Map(), snapshot, prevSnapshot, computeYChange)\n          } else {\n            // No need to render elements that are not visible by either snapshot.\n            // If a client adds and deletes content in the same snapshot the element is not visible by either snapshot.\n            return null\n          }\n        }).filter(n => n !== null)\n        // @ts-ignore\n        const tr = this._tr.replace(0, this.prosemirrorView.state.doc.content.size, new prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Slice(new prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Fragment(fragmentContent), 0, 0))\n        this.prosemirrorView.dispatch(tr.setMeta(_keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey, { isChangeOrigin: true }))\n      }, _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey)\n    })\n  }\n\n  /**\n   * @param {Array<Y.YEvent<any>>} events\n   * @param {Y.Transaction} transaction\n   */\n  _typeChanged (events, transaction) {\n    const syncState = _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey.getState(this.prosemirrorView.state)\n    if (events.length === 0 || syncState.snapshot != null || syncState.prevSnapshot != null) {\n      // drop out if snapshot is active\n      this.renderSnapshot(syncState.snapshot, syncState.prevSnapshot)\n      return\n    }\n    this.mux(() => {\n      /**\n       * @param {any} _\n       * @param {Y.AbstractType<any>} type\n       */\n      const delType = (_, type) => this.mapping.delete(type)\n      yjs__WEBPACK_IMPORTED_MODULE_0__.iterateDeletedStructs(transaction, transaction.deleteSet, struct => struct.constructor === yjs__WEBPACK_IMPORTED_MODULE_0__.Item && this.mapping.delete(/** @type {Y.ContentType} */ (/** @type {Y.Item} */ (struct).content).type))\n      transaction.changed.forEach(delType)\n      transaction.changedParentTypes.forEach(delType)\n      const fragmentContent = this.type.toArray().map(t => createNodeIfNotExists(/** @type {Y.XmlElement | Y.XmlHook} */ (t), this.prosemirrorView.state.schema, this.mapping)).filter(n => n !== null)\n      // @ts-ignore\n      let tr = this._tr.replace(0, this.prosemirrorView.state.doc.content.size, new prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Slice(new prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Fragment(fragmentContent), 0, 0))\n      restoreRelativeSelection(tr, this.beforeTransactionSelection, this)\n      tr = tr.setMeta(_keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey, { isChangeOrigin: true })\n      if (this.beforeTransactionSelection !== null && this._isLocalCursorInView()) {\n        tr.scrollIntoView()\n      }\n      this.prosemirrorView.dispatch(tr)\n    })\n  }\n\n  _prosemirrorChanged (doc) {\n    this.mux(() => {\n      this.doc.transact(() => {\n        updateYFragment(this.doc, this.type, doc, this.mapping)\n        this.beforeTransactionSelection = getRelativeSelection(this, this.prosemirrorView.state)\n      }, _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey)\n    })\n  }\n\n  destroy () {\n    this.isDestroyed = true\n    this.type.unobserveDeep(this._observeFunction)\n    this.doc.off('beforeAllTransactions', this.beforeAllTransactions)\n    this.doc.off('afterAllTransactions', this.afterAllTransactions)\n  }\n}\n\n/**\n * @private\n * @param {Y.XmlElement | Y.XmlHook} el\n * @param {PModel.Schema} schema\n * @param {ProsemirrorMapping} mapping\n * @param {Y.Snapshot} [snapshot]\n * @param {Y.Snapshot} [prevSnapshot]\n * @param {function('removed' | 'added', Y.ID):any} [computeYChange]\n * @return {PModel.Node | null}\n */\nconst createNodeIfNotExists = (el, schema, mapping, snapshot, prevSnapshot, computeYChange) => {\n  const node = /** @type {PModel.Node} */ (mapping.get(el))\n  if (node === undefined) {\n    if (el instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement) {\n      return createNodeFromYElement(el, schema, mapping, snapshot, prevSnapshot, computeYChange)\n    } else {\n      throw lib0_error__WEBPACK_IMPORTED_MODULE_11__.methodUnimplemented() // we are currently not handling hooks\n    }\n  }\n  return node\n}\n\n/**\n * @private\n * @param {Y.XmlElement} el\n * @param {any} schema\n * @param {ProsemirrorMapping} mapping\n * @param {Y.Snapshot} [snapshot]\n * @param {Y.Snapshot} [prevSnapshot]\n * @param {function('removed' | 'added', Y.ID):any} [computeYChange]\n * @return {PModel.Node | null} Returns node if node could be created. Otherwise it deletes the yjs type and returns null\n */\nconst createNodeFromYElement = (el, schema, mapping, snapshot, prevSnapshot, computeYChange) => {\n  const children = []\n  const createChildren = type => {\n    if (type.constructor === yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement) {\n      const n = createNodeIfNotExists(type, schema, mapping, snapshot, prevSnapshot, computeYChange)\n      if (n !== null) {\n        children.push(n)\n      }\n    } else {\n      const ns = createTextNodesFromYText(type, schema, mapping, snapshot, prevSnapshot, computeYChange)\n      if (ns !== null) {\n        ns.forEach(textchild => {\n          if (textchild !== null) {\n            children.push(textchild)\n          }\n        })\n      }\n    }\n  }\n  if (snapshot === undefined || prevSnapshot === undefined) {\n    el.toArray().forEach(createChildren)\n  } else {\n    yjs__WEBPACK_IMPORTED_MODULE_0__.typeListToArraySnapshot(el, new yjs__WEBPACK_IMPORTED_MODULE_0__.Snapshot(prevSnapshot.ds, snapshot.sv)).forEach(createChildren)\n  }\n  try {\n    const attrs = el.getAttributes(snapshot)\n    if (snapshot !== undefined) {\n      if (!isVisible(/** @type {Y.Item} */ (el._item), snapshot)) {\n        attrs.ychange = computeYChange ? computeYChange('removed', /** @type {Y.Item} */ (el._item).id) : { type: 'removed' }\n      } else if (!isVisible(/** @type {Y.Item} */ (el._item), prevSnapshot)) {\n        attrs.ychange = computeYChange ? computeYChange('added', /** @type {Y.Item} */ (el._item).id) : { type: 'added' }\n      }\n    }\n    const node = schema.node(el.nodeName, attrs, children)\n    mapping.set(el, node)\n    return node\n  } catch (e) {\n    // an error occured while creating the node. This is probably a result of a concurrent action.\n    /** @type {Y.Doc} */ (el.doc).transact(transaction => {\n      /** @type {Y.Item} */ (el._item).delete(transaction)\n    }, _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey)\n    mapping.delete(el)\n    return null\n  }\n}\n\n/**\n * @private\n * @param {Y.XmlText} text\n * @param {any} schema\n * @param {ProsemirrorMapping} mapping\n * @param {Y.Snapshot} [snapshot]\n * @param {Y.Snapshot} [prevSnapshot]\n * @param {function('removed' | 'added', Y.ID):any} [computeYChange]\n * @return {Array<PModel.Node>|null}\n */\nconst createTextNodesFromYText = (text, schema, mapping, snapshot, prevSnapshot, computeYChange) => {\n  const nodes = []\n  const deltas = text.toDelta(snapshot, prevSnapshot, computeYChange)\n  try {\n    for (let i = 0; i < deltas.length; i++) {\n      const delta = deltas[i]\n      const marks = []\n      for (const markName in delta.attributes) {\n        marks.push(schema.mark(markName, delta.attributes[markName]))\n      }\n      nodes.push(schema.text(delta.insert, marks))\n    }\n  } catch (e) {\n    // an error occured while creating the node. This is probably a result of a concurrent action.\n    /** @type {Y.Doc} */ (text.doc).transact(transaction => {\n      /** @type {Y.Item} */ (text._item).delete(transaction)\n    }, _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey)\n    return null\n  }\n  // @ts-ignore\n  return nodes\n}\n\n/**\n * @private\n * @param {Array<any>} nodes prosemirror node\n * @param {ProsemirrorMapping} mapping\n * @return {Y.XmlText}\n */\nconst createTypeFromTextNodes = (nodes, mapping) => {\n  const type = new yjs__WEBPACK_IMPORTED_MODULE_0__.XmlText()\n  const delta = nodes.map(node => ({\n    // @ts-ignore\n    insert: node.text,\n    attributes: marksToAttributes(node.marks)\n  }))\n  type.applyDelta(delta)\n  mapping.set(type, nodes)\n  return type\n}\n\n/**\n * @private\n * @param {any} node prosemirror node\n * @param {ProsemirrorMapping} mapping\n * @return {Y.XmlElement}\n */\nconst createTypeFromElementNode = (node, mapping) => {\n  const type = new yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement(node.type.name)\n  for (const key in node.attrs) {\n    const val = node.attrs[key]\n    if (val !== null && key !== 'ychange') {\n      type.setAttribute(key, val)\n    }\n  }\n  type.insert(0, normalizePNodeContent(node).map(n => createTypeFromTextOrElementNode(n, mapping)))\n  mapping.set(type, node)\n  return type\n}\n\n/**\n * @private\n * @param {PModel.Node|Array<PModel.Node>} node prosemirror text node\n * @param {ProsemirrorMapping} mapping\n * @return {Y.XmlElement|Y.XmlText}\n */\nconst createTypeFromTextOrElementNode = (node, mapping) => node instanceof Array ? createTypeFromTextNodes(node, mapping) : createTypeFromElementNode(node, mapping)\n\nconst isObject = (val) => typeof val === 'object' && val !== null\n\nconst equalAttrs = (pattrs, yattrs) => {\n  const keys = Object.keys(pattrs).filter(key => pattrs[key] !== null)\n  let eq = keys.length === Object.keys(yattrs).filter(key => yattrs[key] !== null).length\n  for (let i = 0; i < keys.length && eq; i++) {\n    const key = keys[i]\n    const l = pattrs[key]\n    const r = yattrs[key]\n    eq = key === 'ychange' || l === r || (isObject(l) && isObject(r) && equalAttrs(l, r))\n  }\n  return eq\n}\n\n/**\n * @typedef {Array<Array<PModel.Node>|PModel.Node>} NormalizedPNodeContent\n */\n\n/**\n * @param {any} pnode\n * @return {NormalizedPNodeContent}\n */\nconst normalizePNodeContent = pnode => {\n  const c = pnode.content.content\n  const res = []\n  for (let i = 0; i < c.length; i++) {\n    const n = c[i]\n    if (n.isText) {\n      const textNodes = []\n      for (let tnode = c[i]; i < c.length && tnode.isText; tnode = c[++i]) {\n        textNodes.push(tnode)\n      }\n      i--\n      res.push(textNodes)\n    } else {\n      res.push(n)\n    }\n  }\n  return res\n}\n\n/**\n * @param {Y.XmlText} ytext\n * @param {Array<any>} ptexts\n */\nconst equalYTextPText = (ytext, ptexts) => {\n  const delta = ytext.toDelta()\n  return delta.length === ptexts.length && delta.every((d, i) => d.insert === /** @type {any} */ (ptexts[i]).text && lib0_object__WEBPACK_IMPORTED_MODULE_12__.keys(d.attributes || {}).length === ptexts[i].marks.length && ptexts[i].marks.every(mark => equalAttrs(d.attributes[mark.type.name] || {}, mark.attrs)))\n}\n\n/**\n * @param {Y.XmlElement|Y.XmlText|Y.XmlHook} ytype\n * @param {any|Array<any>} pnode\n */\nconst equalYTypePNode = (ytype, pnode) => {\n  if (ytype instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement && !(pnode instanceof Array) && matchNodeName(ytype, pnode)) {\n    const normalizedContent = normalizePNodeContent(pnode)\n    return ytype._length === normalizedContent.length && equalAttrs(ytype.getAttributes(), pnode.attrs) && ytype.toArray().every((ychild, i) => equalYTypePNode(ychild, normalizedContent[i]))\n  }\n  return ytype instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlText && pnode instanceof Array && equalYTextPText(ytype, pnode)\n}\n\n/**\n * @param {PModel.Node | Array<PModel.Node> | undefined} mapped\n * @param {PModel.Node | Array<PModel.Node>} pcontent\n */\nconst mappedIdentity = (mapped, pcontent) => mapped === pcontent || (mapped instanceof Array && pcontent instanceof Array && mapped.length === pcontent.length && mapped.every((a, i) => pcontent[i] === a))\n\n/**\n * @param {Y.XmlElement} ytype\n * @param {PModel.Node} pnode\n * @param {ProsemirrorMapping} mapping\n * @return {{ foundMappedChild: boolean, equalityFactor: number }}\n */\nconst computeChildEqualityFactor = (ytype, pnode, mapping) => {\n  const yChildren = ytype.toArray()\n  const pChildren = normalizePNodeContent(pnode)\n  const pChildCnt = pChildren.length\n  const yChildCnt = yChildren.length\n  const minCnt = lib0_math__WEBPACK_IMPORTED_MODULE_13__.min(yChildCnt, pChildCnt)\n  let left = 0\n  let right = 0\n  let foundMappedChild = false\n  for (; left < minCnt; left++) {\n    const leftY = yChildren[left]\n    const leftP = pChildren[left]\n    if (mappedIdentity(mapping.get(leftY), leftP)) {\n      foundMappedChild = true// definite (good) match!\n    } else if (!equalYTypePNode(leftY, leftP)) {\n      break\n    }\n  }\n  for (; left + right < minCnt; right++) {\n    const rightY = yChildren[yChildCnt - right - 1]\n    const rightP = pChildren[pChildCnt - right - 1]\n    if (mappedIdentity(mapping.get(rightY), rightP)) {\n      foundMappedChild = true\n    } else if (!equalYTypePNode(rightY, rightP)) {\n      break\n    }\n  }\n  return {\n    equalityFactor: left + right,\n    foundMappedChild\n  }\n}\n\nconst ytextTrans = ytext => {\n  let str = ''\n  /**\n   * @type {Y.Item|null}\n   */\n  let n = ytext._start\n  const nAttrs = {}\n  while (n !== null) {\n    if (!n.deleted) {\n      if (n.countable && n.content instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.ContentString) {\n        str += n.content.str\n      } else if (n.content instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.ContentFormat) {\n        nAttrs[n.content.key] = null\n      }\n    }\n    n = n.right\n  }\n  return {\n    str,\n    nAttrs\n  }\n}\n\n/**\n * @todo test this more\n *\n * @param {Y.Text} ytext\n * @param {Array<any>} ptexts\n * @param {ProsemirrorMapping} mapping\n */\nconst updateYText = (ytext, ptexts, mapping) => {\n  mapping.set(ytext, ptexts)\n  const { nAttrs, str } = ytextTrans(ytext)\n  const content = ptexts.map(p => ({ insert: /** @type {any} */ (p).text, attributes: Object.assign({}, nAttrs, marksToAttributes(p.marks)) }))\n  const { insert, remove, index } = (0,lib0_diff__WEBPACK_IMPORTED_MODULE_14__.simpleDiff)(str, content.map(c => c.insert).join(''))\n  ytext.delete(index, remove)\n  ytext.insert(index, insert)\n  ytext.applyDelta(content.map(c => ({ retain: c.insert.length, attributes: c.attributes })))\n}\n\nconst marksToAttributes = marks => {\n  const pattrs = {}\n  marks.forEach(mark => {\n    if (mark.type.name !== 'ychange') {\n      pattrs[mark.type.name] = mark.attrs\n    }\n  })\n  return pattrs\n}\n\n/**\n * @private\n * @param {{transact: Function}} y\n * @param {Y.XmlFragment} yDomFragment\n * @param {any} pNode\n * @param {ProsemirrorMapping} mapping\n */\nconst updateYFragment = (y, yDomFragment, pNode, mapping) => {\n  if (yDomFragment instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement && yDomFragment.nodeName !== pNode.type.name) {\n    throw new Error('node name mismatch!')\n  }\n  mapping.set(yDomFragment, pNode)\n  // update attributes\n  if (yDomFragment instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement) {\n    const yDomAttrs = yDomFragment.getAttributes()\n    const pAttrs = pNode.attrs\n    for (const key in pAttrs) {\n      if (pAttrs[key] !== null) {\n        if (yDomAttrs[key] !== pAttrs[key] && key !== 'ychange') {\n          yDomFragment.setAttribute(key, pAttrs[key])\n        }\n      } else {\n        yDomFragment.removeAttribute(key)\n      }\n    }\n    // remove all keys that are no longer in pAttrs\n    for (const key in yDomAttrs) {\n      if (pAttrs[key] === undefined) {\n        yDomFragment.removeAttribute(key)\n      }\n    }\n  }\n  // update children\n  const pChildren = normalizePNodeContent(pNode)\n  const pChildCnt = pChildren.length\n  const yChildren = yDomFragment.toArray()\n  const yChildCnt = yChildren.length\n  const minCnt = lib0_math__WEBPACK_IMPORTED_MODULE_13__.min(pChildCnt, yChildCnt)\n  let left = 0\n  let right = 0\n  // find number of matching elements from left\n  for (;left < minCnt; left++) {\n    const leftY = yChildren[left]\n    const leftP = pChildren[left]\n    if (!mappedIdentity(mapping.get(leftY), leftP)) {\n      if (equalYTypePNode(leftY, leftP)) {\n        // update mapping\n        mapping.set(leftY, leftP)\n      } else {\n        break\n      }\n    }\n  }\n  // find number of matching elements from right\n  for (;right + left + 1 < minCnt; right++) {\n    const rightY = yChildren[yChildCnt - right - 1]\n    const rightP = pChildren[pChildCnt - right - 1]\n    if (!mappedIdentity(mapping.get(rightY), rightP)) {\n      if (equalYTypePNode(rightY, rightP)) {\n        // update mapping\n        mapping.set(rightY, rightP)\n      } else {\n        break\n      }\n    }\n  }\n  y.transact(() => {\n    // try to compare and update\n    while (yChildCnt - left - right > 0 && pChildCnt - left - right > 0) {\n      const leftY = yChildren[left]\n      const leftP = pChildren[left]\n      const rightY = yChildren[yChildCnt - right - 1]\n      const rightP = pChildren[pChildCnt - right - 1]\n      if (leftY instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlText && leftP instanceof Array) {\n        if (!equalYTextPText(leftY, leftP)) {\n          updateYText(leftY, leftP, mapping)\n        }\n        left += 1\n      } else {\n        let updateLeft = leftY instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement && matchNodeName(leftY, leftP)\n        let updateRight = rightY instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement && matchNodeName(rightY, rightP)\n        if (updateLeft && updateRight) {\n          // decide which which element to update\n          const equalityLeft = computeChildEqualityFactor(/** @type {Y.XmlElement} */ (leftY), /** @type {PModel.Node} */ (leftP), mapping)\n          const equalityRight = computeChildEqualityFactor(/** @type {Y.XmlElement} */ (rightY), /** @type {PModel.Node} */ (rightP), mapping)\n          if (equalityLeft.foundMappedChild && !equalityRight.foundMappedChild) {\n            updateRight = false\n          } else if (!equalityLeft.foundMappedChild && equalityRight.foundMappedChild) {\n            updateLeft = false\n          } else if (equalityLeft.equalityFactor < equalityRight.equalityFactor) {\n            updateLeft = false\n          } else {\n            updateRight = false\n          }\n        }\n        if (updateLeft) {\n          updateYFragment(y, /** @type {Y.XmlFragment} */ (leftY), /** @type {PModel.Node} */ (leftP), mapping)\n          left += 1\n        } else if (updateRight) {\n          updateYFragment(y, /** @type {Y.XmlFragment} */ (rightY), /** @type {PModel.Node} */ (rightP), mapping)\n          right += 1\n        } else {\n          yDomFragment.delete(left, 1)\n          yDomFragment.insert(left, [createTypeFromTextOrElementNode(leftP, mapping)])\n          left += 1\n        }\n      }\n    }\n    const yDelLen = yChildCnt - left - right\n    if (yChildCnt === 1 && pChildCnt === 0 && yChildren[0] instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlText) {\n      // Edge case handling https://github.com/yjs/y-prosemirror/issues/108\n      // Only delete the content of the Y.Text to retain remote changes on the same Y.Text object\n      yChildren[0].delete(0, yChildren[0].length)\n    } else if (yDelLen > 0) {\n      yDomFragment.delete(left, yDelLen)\n    }\n    if (left + right < pChildCnt) {\n      const ins = []\n      for (let i = left; i < pChildCnt - right; i++) {\n        ins.push(createTypeFromTextOrElementNode(pChildren[i], mapping))\n      }\n      yDomFragment.insert(left, ins)\n    }\n  }, _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey)\n}\n\n/**\n * @function\n * @param {Y.XmlElement} yElement\n * @param {any} pNode Prosemirror Node\n */\nconst matchNodeName = (yElement, pNode) => !(pNode instanceof Array) && yElement.nodeName === pNode.type.name\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveS1wcm9zZW1pcnJvci9zcmMvcGx1Z2lucy9zeW5jLXBsdWdpbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFd0M7QUFDRztBQUNjO0FBQ3hCO0FBQ0k7QUFDTjtBQUNPO0FBQ0g7QUFDTztBQUNsQjtBQUMwRTtBQUM3RDtBQUNVO0FBQ2hCO0FBQ1k7O0FBRTNDO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsWUFBWTtBQUN2QjtBQUNPLDhIQUE4SCxRQUFRLHlEQUF5RCwwQ0FBVzs7QUFFak47QUFDQTtBQUNBLGFBQWEsNERBQTREO0FBQ3pFOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxpQkFBaUI7QUFDL0IsY0FBYyxzQkFBc0I7QUFDcEMsY0FBYywwQkFBMEI7QUFDeEMsY0FBYyxVQUFVO0FBQ3hCOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EseUJBQXlCLHFDQUFxQzs7QUFFOUQ7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQyxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNENBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhDQUFZO0FBQ3ZDO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxXQUFXO0FBQ3RCLFlBQVksS0FBSztBQUNqQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTjtBQUNBO0FBQ0EscUJBQXFCLHFEQUFNO0FBQzNCO0FBQ0E7QUFDQSwwQkFBMEIsb0RBQWM7QUFDeEM7QUFDQTtBQUNBLEtBQUs7QUFDTCxTQUFTLG9E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QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsd0NBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsMENBQTBDLDJDQUFZO0FBQ3RELDRDQUE0QywyQ0FBWTtBQUN4RDtBQUNBO0FBQ0EscUVBQXFFLGNBQWMsdUJBQXVCLGFBQWE7QUFDdkgsc0VBQXNFLGNBQWMsd0JBQXdCLGFBQWE7QUFDekg7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxlQUFlLHVCQUF1QixhQUFhO0FBQzNGO0FBQ0EsVUFBVTtBQUNWLHdDQUF3QyxlQUFlLHdCQUF3QixhQUFhO0FBQzVGO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLHdDQUFTO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUUsb0RBQWM7QUFDbkI7O0FBRUE7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLEtBQUs7QUFDaEI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3plbmJvYXJkLy4vbm9kZV9tb2R1bGVzL3ktcHJvc2VtaXJyb3Ivc3JjL3BsdWdpbnMvc3luYy1wbHVnaW4uanM/OTBlMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgYmluZGluZ3MvcHJvc2VtaXJyb3JcbiAqL1xuXG5pbXBvcnQgeyBjcmVhdGVNdXRleCB9IGZyb20gJ2xpYjAvbXV0ZXgnXG5pbXBvcnQgKiBhcyBQTW9kZWwgZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnXG5pbXBvcnQgeyBQbHVnaW4sIFRleHRTZWxlY3Rpb24gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZScgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuaW1wb3J0ICogYXMgbWF0aCBmcm9tICdsaWIwL21hdGgnXG5pbXBvcnQgKiBhcyBvYmplY3QgZnJvbSAnbGliMC9vYmplY3QnXG5pbXBvcnQgKiBhcyBzZXQgZnJvbSAnbGliMC9zZXQnXG5pbXBvcnQgeyBzaW1wbGVEaWZmIH0gZnJvbSAnbGliMC9kaWZmJ1xuaW1wb3J0ICogYXMgZXJyb3IgZnJvbSAnbGliMC9lcnJvcidcbmltcG9ydCB7IHlTeW5jUGx1Z2luS2V5IH0gZnJvbSAnLi9rZXlzLmpzJ1xuaW1wb3J0ICogYXMgWSBmcm9tICd5anMnXG5pbXBvcnQgeyBhYnNvbHV0ZVBvc2l0aW9uVG9SZWxhdGl2ZVBvc2l0aW9uLCByZWxhdGl2ZVBvc2l0aW9uVG9BYnNvbHV0ZVBvc2l0aW9uIH0gZnJvbSAnLi4vbGliLmpzJ1xuaW1wb3J0ICogYXMgcmFuZG9tIGZyb20gJ2xpYjAvcmFuZG9tJ1xuaW1wb3J0ICogYXMgZW52aXJvbm1lbnQgZnJvbSAnbGliMC9lbnZpcm9ubWVudCdcbmltcG9ydCAqIGFzIGRvbSBmcm9tICdsaWIwL2RvbSdcbmltcG9ydCAqIGFzIGV2ZW50bG9vcCBmcm9tICdsaWIwL2V2ZW50bG9vcCdcblxuLyoqXG4gKiBAcGFyYW0ge1kuSXRlbX0gaXRlbVxuICogQHBhcmFtIHtZLlNuYXBzaG90fSBbc25hcHNob3RdXG4gKi9cbmV4cG9ydCBjb25zdCBpc1Zpc2libGUgPSAoaXRlbSwgc25hcHNob3QpID0+IHNuYXBzaG90ID09PSB1bmRlZmluZWQgPyAhaXRlbS5kZWxldGVkIDogKHNuYXBzaG90LnN2LmhhcyhpdGVtLmlkLmNsaWVudCkgJiYgLyoqIEB0eXBlIHtudW1iZXJ9ICovIChzbmFwc2hvdC5zdi5nZXQoaXRlbS5pZC5jbGllbnQpKSA+IGl0ZW0uaWQuY2xvY2sgJiYgIVkuaXNEZWxldGVkKHNuYXBzaG90LmRzLCBpdGVtLmlkKSlcblxuLyoqXG4gKiBFaXRoZXIgYSBub2RlIGlmIHR5cGUgaXMgWVhtbEVsZW1lbnQgb3IgYW4gQXJyYXkgb2YgdGV4dCBub2RlcyBpZiBZWG1sVGV4dFxuICogQHR5cGVkZWYge01hcDxZLkFic3RyYWN0VHlwZTxhbnk+LCBQTW9kZWwuTm9kZSB8IEFycmF5PFBNb2RlbC5Ob2RlPj59IFByb3NlbWlycm9yTWFwcGluZ1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ29sb3JEZWZcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBDb2xvckRlZi5saWdodFxuICogQHByb3BlcnR5IHtzdHJpbmd9IENvbG9yRGVmLmRhcmtcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFlTeW5jT3B0c1xuICogQHByb3BlcnR5IHtBcnJheTxDb2xvckRlZj59IFtZU3luY09wdHMuY29sb3JzXVxuICogQHByb3BlcnR5IHtNYXA8c3RyaW5nLENvbG9yRGVmPn0gW1lTeW5jT3B0cy5jb2xvck1hcHBpbmddXG4gKiBAcHJvcGVydHkge1kuUGVybWFuZW50VXNlckRhdGF8bnVsbH0gW1lTeW5jT3B0cy5wZXJtYW5lbnRVc2VyRGF0YV1cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtZU3luY09wdHMub25GaXJzdFJlbmRlcl0gRmlyZWQgd2hlbiB0aGUgY29udGVudCBmcm9tIFlqcyBpcyBpbml0aWFsbHkgcmVuZGVyZWQgdG8gUHJvc2VNaXJyb3JcbiAqL1xuXG4vKipcbiAqIEB0eXBlIHtBcnJheTxDb2xvckRlZj59XG4gKi9cbmNvbnN0IGRlZmF1bHRDb2xvcnMgPSBbeyBsaWdodDogJyNlY2Q0NDQzMycsIGRhcms6ICcjZWNkNDQ0JyB9XVxuXG4vKipcbiAqIEBwYXJhbSB7TWFwPHN0cmluZyxDb2xvckRlZj59IGNvbG9yTWFwcGluZ1xuICogQHBhcmFtIHtBcnJheTxDb2xvckRlZj59IGNvbG9yc1xuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJcbiAqIEByZXR1cm4ge0NvbG9yRGVmfVxuICovXG5jb25zdCBnZXRVc2VyQ29sb3IgPSAoY29sb3JNYXBwaW5nLCBjb2xvcnMsIHVzZXIpID0+IHtcbiAgLy8gQHRvZG8gZG8gbm90IGhpdCB0aGUgc2FtZSBjb2xvciB0d2ljZSBpZiBwb3NzaWJsZVxuICBpZiAoIWNvbG9yTWFwcGluZy5oYXModXNlcikpIHtcbiAgICBpZiAoY29sb3JNYXBwaW5nLnNpemUgPCBjb2xvcnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCB1c2VkQ29sb3JzID0gc2V0LmNyZWF0ZSgpXG4gICAgICBjb2xvck1hcHBpbmcuZm9yRWFjaChjb2xvciA9PiB1c2VkQ29sb3JzLmFkZChjb2xvcikpXG4gICAgICBjb2xvcnMgPSBjb2xvcnMuZmlsdGVyKGNvbG9yID0+ICF1c2VkQ29sb3JzLmhhcyhjb2xvcikpXG4gICAgfVxuICAgIGNvbG9yTWFwcGluZy5zZXQodXNlciwgcmFuZG9tLm9uZU9mKGNvbG9ycykpXG4gIH1cbiAgcmV0dXJuIC8qKiBAdHlwZSB7Q29sb3JEZWZ9ICovIChjb2xvck1hcHBpbmcuZ2V0KHVzZXIpKVxufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGxpc3RlbnMgdG8gY2hhbmdlcyBpbiBwcm9zZW1pcnJvciB2aWV3IGFuZCBrZWVwcyB5WG1sU3RhdGUgYW5kIHZpZXcgaW4gc3luYy5cbiAqXG4gKiBUaGlzIHBsdWdpbiBhbHNvIGtlZXBzIHJlZmVyZW5jZXMgdG8gdGhlIHR5cGUgYW5kIHRoZSBzaGFyZWQgZG9jdW1lbnQgc28gb3RoZXIgcGx1Z2lucyBjYW4gYWNjZXNzIGl0LlxuICogQHBhcmFtIHtZLlhtbEZyYWdtZW50fSB5WG1sRnJhZ21lbnRcbiAqIEBwYXJhbSB7WVN5bmNPcHRzfSBvcHRzXG4gKiBAcmV0dXJuIHthbnl9IFJldHVybnMgYSBwcm9zZW1pcnJvciBwbHVnaW4gdGhhdCBiaW5kcyB0byB0aGlzIHR5cGVcbiAqL1xuZXhwb3J0IGNvbnN0IHlTeW5jUGx1Z2luID0gKHlYbWxGcmFnbWVudCwge1xuICBjb2xvcnMgPSBkZWZhdWx0Q29sb3JzLFxuICBjb2xvck1hcHBpbmcgPSBuZXcgTWFwKCksXG4gIHBlcm1hbmVudFVzZXJEYXRhID0gbnVsbCxcbiAgb25GaXJzdFJlbmRlciA9ICgpID0+IHt9XG59ID0ge30pID0+IHtcbiAgbGV0IGNoYW5nZWRJbml0aWFsQ29udGVudCA9IGZhbHNlXG4gIGxldCByZXJlbmRlclRpbWVvdXRJZFxuICBjb25zdCBwbHVnaW4gPSBuZXcgUGx1Z2luKHtcbiAgICBwcm9wczoge1xuICAgICAgZWRpdGFibGU6IChzdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBzeW5jU3RhdGUgPSB5U3luY1BsdWdpbktleS5nZXRTdGF0ZShzdGF0ZSlcbiAgICAgICAgcmV0dXJuIHN5bmNTdGF0ZS5zbmFwc2hvdCA9PSBudWxsICYmIHN5bmNTdGF0ZS5wcmV2U25hcHNob3QgPT0gbnVsbFxuICAgICAgfVxuICAgIH0sXG4gICAga2V5OiB5U3luY1BsdWdpbktleSxcbiAgICBzdGF0ZToge1xuICAgICAgaW5pdDogKGluaXRhcmdzLCBzdGF0ZSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IHlYbWxGcmFnbWVudCxcbiAgICAgICAgICBkb2M6IHlYbWxGcmFnbWVudC5kb2MsXG4gICAgICAgICAgYmluZGluZzogbnVsbCxcbiAgICAgICAgICBzbmFwc2hvdDogbnVsbCxcbiAgICAgICAgICBwcmV2U25hcHNob3Q6IG51bGwsXG4gICAgICAgICAgaXNDaGFuZ2VPcmlnaW46IGZhbHNlLFxuICAgICAgICAgIGNvbG9ycyxcbiAgICAgICAgICBjb2xvck1hcHBpbmcsXG4gICAgICAgICAgcGVybWFuZW50VXNlckRhdGFcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFwcGx5OiAodHIsIHBsdWdpblN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoYW5nZSA9IHRyLmdldE1ldGEoeVN5bmNQbHVnaW5LZXkpXG4gICAgICAgIGlmIChjaGFuZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBsdWdpblN0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgcGx1Z2luU3RhdGUpXG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY2hhbmdlKSB7XG4gICAgICAgICAgICBwbHVnaW5TdGF0ZVtrZXldID0gY2hhbmdlW2tleV1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWx3YXlzIHNldCBpc0NoYW5nZU9yaWdpbi4gSWYgdW5kZWZpbmVkLCB0aGlzIGlzIG5vdCBjaGFuZ2Ugb3JpZ2luLlxuICAgICAgICBwbHVnaW5TdGF0ZS5pc0NoYW5nZU9yaWdpbiA9IGNoYW5nZSAhPT0gdW5kZWZpbmVkICYmICEhY2hhbmdlLmlzQ2hhbmdlT3JpZ2luXG4gICAgICAgIGlmIChwbHVnaW5TdGF0ZS5iaW5kaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKGNoYW5nZSAhPT0gdW5kZWZpbmVkICYmIChjaGFuZ2Uuc25hcHNob3QgIT0gbnVsbCB8fCBjaGFuZ2UucHJldlNuYXBzaG90ICE9IG51bGwpKSB7XG4gICAgICAgICAgICAvLyBzbmFwc2hvdCBjaGFuZ2VkLCByZXJlbmRlciBuZXh0XG4gICAgICAgICAgICBldmVudGxvb3AudGltZW91dCgwLCAoKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChwbHVnaW5TdGF0ZS5iaW5kaW5nID09IG51bGwgfHwgcGx1Z2luU3RhdGUuYmluZGluZy5pc0Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjaGFuZ2UucmVzdG9yZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGx1Z2luU3RhdGUuYmluZGluZy5fcmVuZGVyU25hcHNob3QoY2hhbmdlLnNuYXBzaG90LCBjaGFuZ2UucHJldlNuYXBzaG90LCBwbHVnaW5TdGF0ZSlcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwbHVnaW5TdGF0ZS5iaW5kaW5nLl9yZW5kZXJTbmFwc2hvdChjaGFuZ2Uuc25hcHNob3QsIGNoYW5nZS5zbmFwc2hvdCwgcGx1Z2luU3RhdGUpXG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgdG8gY3VycmVudCBwcm9zZW1pcnJvciBzdGF0ZVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBwbHVnaW5TdGF0ZS5yZXN0b3JlXG4gICAgICAgICAgICAgICAgZGVsZXRlIHBsdWdpblN0YXRlLnNuYXBzaG90XG4gICAgICAgICAgICAgICAgZGVsZXRlIHBsdWdpblN0YXRlLnByZXZTbmFwc2hvdFxuICAgICAgICAgICAgICAgIHBsdWdpblN0YXRlLmJpbmRpbmcuX3Byb3NlbWlycm9yQ2hhbmdlZChwbHVnaW5TdGF0ZS5iaW5kaW5nLnByb3NlbWlycm9yVmlldy5zdGF0ZS5kb2MpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwbHVnaW5TdGF0ZVxuICAgICAgfVxuICAgIH0sXG4gICAgdmlldzogdmlldyA9PiB7XG4gICAgICBjb25zdCBiaW5kaW5nID0gbmV3IFByb3NlbWlycm9yQmluZGluZyh5WG1sRnJhZ21lbnQsIHZpZXcpXG4gICAgICBpZiAocmVyZW5kZXJUaW1lb3V0SWQgIT0gbnVsbCkge1xuICAgICAgICBjbGVhclRpbWVvdXQocmVyZW5kZXJUaW1lb3V0SWQpXG4gICAgICB9XG4gICAgICAvLyBNYWtlIHN1cmUgdGhpcyBpcyBjYWxsZWQgaW4gYSBzZXBhcmF0ZSBjb250ZXh0XG4gICAgICByZXJlbmRlclRpbWVvdXRJZCA9IGV2ZW50bG9vcC50aW1lb3V0KDAsICgpID0+IHtcbiAgICAgICAgYmluZGluZy5fZm9yY2VSZXJlbmRlcigpXG4gICAgICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5zZXRNZXRhKHlTeW5jUGx1Z2luS2V5LCB7IGJpbmRpbmcgfSkpXG4gICAgICAgIG9uRmlyc3RSZW5kZXIoKVxuICAgICAgfSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZTogKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHBsdWdpblN0YXRlID0gcGx1Z2luLmdldFN0YXRlKHZpZXcuc3RhdGUpXG4gICAgICAgICAgaWYgKHBsdWdpblN0YXRlLnNuYXBzaG90ID09IG51bGwgJiYgcGx1Z2luU3RhdGUucHJldlNuYXBzaG90ID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VkSW5pdGlhbENvbnRlbnQgfHwgdmlldy5zdGF0ZS5kb2MuY29udGVudC5maW5kRGlmZlN0YXJ0KHZpZXcuc3RhdGUuZG9jLnR5cGUuY3JlYXRlQW5kRmlsbCgpLmNvbnRlbnQpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGNoYW5nZWRJbml0aWFsQ29udGVudCA9IHRydWVcbiAgICAgICAgICAgICAgYmluZGluZy5fcHJvc2VtaXJyb3JDaGFuZ2VkKHZpZXcuc3RhdGUuZG9jKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgICAgIGNsZWFyVGltZW91dChyZXJlbmRlclRpbWVvdXRJZClcbiAgICAgICAgICBiaW5kaW5nLmRlc3Ryb3koKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gcGx1Z2luXG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHRyXG4gKiBAcGFyYW0ge2FueX0gcmVsU2VsXG4gKiBAcGFyYW0ge1Byb3NlbWlycm9yQmluZGluZ30gYmluZGluZ1xuICovXG5jb25zdCByZXN0b3JlUmVsYXRpdmVTZWxlY3Rpb24gPSAodHIsIHJlbFNlbCwgYmluZGluZykgPT4ge1xuICBpZiAocmVsU2VsICE9PSBudWxsICYmIHJlbFNlbC5hbmNob3IgIT09IG51bGwgJiYgcmVsU2VsLmhlYWQgIT09IG51bGwpIHtcbiAgICBjb25zdCBhbmNob3IgPSByZWxhdGl2ZVBvc2l0aW9uVG9BYnNvbHV0ZVBvc2l0aW9uKGJpbmRpbmcuZG9jLCBiaW5kaW5nLnR5cGUsIHJlbFNlbC5hbmNob3IsIGJpbmRpbmcubWFwcGluZylcbiAgICBjb25zdCBoZWFkID0gcmVsYXRpdmVQb3NpdGlvblRvQWJzb2x1dGVQb3NpdGlvbihiaW5kaW5nLmRvYywgYmluZGluZy50eXBlLCByZWxTZWwuaGVhZCwgYmluZGluZy5tYXBwaW5nKVxuICAgIGlmIChhbmNob3IgIT09IG51bGwgJiYgaGVhZCAhPT0gbnVsbCkge1xuICAgICAgdHIgPSB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCBhbmNob3IsIGhlYWQpKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZ2V0UmVsYXRpdmVTZWxlY3Rpb24gPSAocG1iaW5kaW5nLCBzdGF0ZSkgPT4gKHtcbiAgYW5jaG9yOiBhYnNvbHV0ZVBvc2l0aW9uVG9SZWxhdGl2ZVBvc2l0aW9uKHN0YXRlLnNlbGVjdGlvbi5hbmNob3IsIHBtYmluZGluZy50eXBlLCBwbWJpbmRpbmcubWFwcGluZyksXG4gIGhlYWQ6IGFic29sdXRlUG9zaXRpb25Ub1JlbGF0aXZlUG9zaXRpb24oc3RhdGUuc2VsZWN0aW9uLmhlYWQsIHBtYmluZGluZy50eXBlLCBwbWJpbmRpbmcubWFwcGluZylcbn0pXG5cbi8qKlxuICogQmluZGluZyBmb3IgcHJvc2VtaXJyb3IuXG4gKlxuICogQHByb3RlY3RlZFxuICovXG5leHBvcnQgY2xhc3MgUHJvc2VtaXJyb3JCaW5kaW5nIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7WS5YbWxGcmFnbWVudH0geVhtbEZyYWdtZW50IFRoZSBiaW5kIHNvdXJjZVxuICAgKiBAcGFyYW0ge2FueX0gcHJvc2VtaXJyb3JWaWV3IFRoZSB0YXJnZXQgYmluZGluZ1xuICAgKi9cbiAgY29uc3RydWN0b3IgKHlYbWxGcmFnbWVudCwgcHJvc2VtaXJyb3JWaWV3KSB7XG4gICAgdGhpcy50eXBlID0geVhtbEZyYWdtZW50XG4gICAgdGhpcy5wcm9zZW1pcnJvclZpZXcgPSBwcm9zZW1pcnJvclZpZXdcbiAgICB0aGlzLm11eCA9IGNyZWF0ZU11dGV4KClcbiAgICB0aGlzLmlzRGVzdHJveWVkID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7UHJvc2VtaXJyb3JNYXBwaW5nfVxuICAgICAqL1xuICAgIHRoaXMubWFwcGluZyA9IG5ldyBNYXAoKVxuICAgIHRoaXMuX29ic2VydmVGdW5jdGlvbiA9IHRoaXMuX3R5cGVDaGFuZ2VkLmJpbmQodGhpcylcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7WS5Eb2N9XG4gICAgICovXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuZG9jID0geVhtbEZyYWdtZW50LmRvY1xuICAgIC8qKlxuICAgICAqIGN1cnJlbnQgc2VsZWN0aW9uIGFzIHJlbGF0aXZlIHBvc2l0aW9ucyBpbiB0aGUgWWpzIG1vZGVsXG4gICAgICovXG4gICAgdGhpcy5iZWZvcmVUcmFuc2FjdGlvblNlbGVjdGlvbiA9IG51bGxcbiAgICB0aGlzLmJlZm9yZUFsbFRyYW5zYWN0aW9ucyA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmJlZm9yZVRyYW5zYWN0aW9uU2VsZWN0aW9uID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuYmVmb3JlVHJhbnNhY3Rpb25TZWxlY3Rpb24gPSBnZXRSZWxhdGl2ZVNlbGVjdGlvbih0aGlzLCBwcm9zZW1pcnJvclZpZXcuc3RhdGUpXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYWZ0ZXJBbGxUcmFuc2FjdGlvbnMgPSAoKSA9PiB7XG4gICAgICB0aGlzLmJlZm9yZVRyYW5zYWN0aW9uU2VsZWN0aW9uID0gbnVsbFxuICAgIH1cblxuICAgIHRoaXMuZG9jLm9uKCdiZWZvcmVBbGxUcmFuc2FjdGlvbnMnLCB0aGlzLmJlZm9yZUFsbFRyYW5zYWN0aW9ucylcbiAgICB0aGlzLmRvYy5vbignYWZ0ZXJBbGxUcmFuc2FjdGlvbnMnLCB0aGlzLmFmdGVyQWxsVHJhbnNhY3Rpb25zKVxuICAgIHlYbWxGcmFnbWVudC5vYnNlcnZlRGVlcCh0aGlzLl9vYnNlcnZlRnVuY3Rpb24pXG5cbiAgICB0aGlzLl9kb21TZWxlY3Rpb25JblZpZXcgPSBudWxsXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgdHJhbnNhY3Rpb24gZm9yIGNoYW5naW5nIHRoZSBwcm9zZW1pcnJvciBzdGF0ZS5cbiAgICpcbiAgICogQHJldHVybnNcbiAgICovXG4gIGdldCBfdHIgKCkge1xuICAgIHJldHVybiB0aGlzLnByb3NlbWlycm9yVmlldy5zdGF0ZS50ci5zZXRNZXRhKCdhZGRUb0hpc3RvcnknLCBmYWxzZSlcbiAgfVxuXG4gIF9pc0xvY2FsQ3Vyc29ySW5WaWV3ICgpIHtcbiAgICBpZiAoIXRoaXMucHJvc2VtaXJyb3JWaWV3Lmhhc0ZvY3VzKCkpIHJldHVybiBmYWxzZVxuICAgIGlmIChlbnZpcm9ubWVudC5pc0Jyb3dzZXIgJiYgdGhpcy5fZG9tU2VsZWN0aW9uSW5WaWV3ID09PSBudWxsKSB7XG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIGRvbVNlbGVjdGlvbkluVmlldyBhbmQgY2xlYXIgYnkgbmV4dCB0aWNrIGFmdGVyIGFsbCBldmVudHMgYXJlIGZpbmlzaGVkXG4gICAgICBldmVudGxvb3AudGltZW91dCgwLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2RvbVNlbGVjdGlvbkluVmlldyA9IG51bGxcbiAgICAgIH0pXG4gICAgICB0aGlzLl9kb21TZWxlY3Rpb25JblZpZXcgPSB0aGlzLl9pc0RvbVNlbGVjdGlvbkluVmlldygpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9kb21TZWxlY3Rpb25JblZpZXdcbiAgfVxuXG4gIF9pc0RvbVNlbGVjdGlvbkluVmlldyAoKSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gdGhpcy5wcm9zZW1pcnJvclZpZXcuX3Jvb3QuZ2V0U2VsZWN0aW9uKClcblxuICAgIGNvbnN0IHJhbmdlID0gdGhpcy5wcm9zZW1pcnJvclZpZXcuX3Jvb3QuY3JlYXRlUmFuZ2UoKVxuICAgIHJhbmdlLnNldFN0YXJ0KHNlbGVjdGlvbi5hbmNob3JOb2RlLCBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0KVxuICAgIHJhbmdlLnNldEVuZChzZWxlY3Rpb24uZm9jdXNOb2RlLCBzZWxlY3Rpb24uZm9jdXNPZmZzZXQpXG5cbiAgICAvLyBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3IgYW4gZWRnZWNhc2Ugd2hlcmUgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IHdpbGxcbiAgICAvLyByZXR1cm4gemVybyB2YWx1ZXMgaWYgdGhlIHNlbGVjdGlvbiBpcyBjb2xsYXBzZWQgYXQgdGhlIHN0YXJ0IG9mIGEgbmV3bGluZVxuICAgIC8vIHNlZSByZWZlcmVuY2UgaGVyZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzU5NzgwOTU0XG4gICAgY29uc3QgcmVjdHMgPSByYW5nZS5nZXRDbGllbnRSZWN0cygpXG4gICAgaWYgKHJlY3RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gcHJvYmFibHkgYnVnZ3kgbmV3bGluZSBiZWhhdmlvciwgZXhwbGljaXRseSBzZWxlY3QgdGhlIG5vZGUgY29udGVudHNcbiAgICAgIGlmIChyYW5nZS5zdGFydENvbnRhaW5lciAmJiByYW5nZS5jb2xsYXBzZWQpIHtcbiAgICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKHJhbmdlLnN0YXJ0Q29udGFpbmVyKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGJvdW5kaW5nID0gcmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICBjb25zdCBkb2N1bWVudEVsZW1lbnQgPSBkb20uZG9jLmRvY3VtZW50RWxlbWVudFxuXG4gICAgcmV0dXJuIGJvdW5kaW5nLmJvdHRvbSA+PSAwICYmIGJvdW5kaW5nLnJpZ2h0ID49IDAgJiZcbiAgICAgIGJvdW5kaW5nLmxlZnQgPD0gKHdpbmRvdy5pbm5lcldpZHRoIHx8IGRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCB8fCAwKSAmJlxuICAgICAgYm91bmRpbmcudG9wIDw9ICh3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCB8fCAwKVxuICB9XG5cbiAgcmVuZGVyU25hcHNob3QgKHNuYXBzaG90LCBwcmV2U25hcHNob3QpIHtcbiAgICBpZiAoIXByZXZTbmFwc2hvdCkge1xuICAgICAgcHJldlNuYXBzaG90ID0gWS5jcmVhdGVTbmFwc2hvdChZLmNyZWF0ZURlbGV0ZVNldCgpLCBuZXcgTWFwKCkpXG4gICAgfVxuICAgIHRoaXMucHJvc2VtaXJyb3JWaWV3LmRpc3BhdGNoKHRoaXMuX3RyLnNldE1ldGEoeVN5bmNQbHVnaW5LZXksIHsgc25hcHNob3QsIHByZXZTbmFwc2hvdCB9KSlcbiAgfVxuXG4gIHVucmVuZGVyU25hcHNob3QgKCkge1xuICAgIHRoaXMubWFwcGluZyA9IG5ldyBNYXAoKVxuICAgIHRoaXMubXV4KCgpID0+IHtcbiAgICAgIGNvbnN0IGZyYWdtZW50Q29udGVudCA9IHRoaXMudHlwZS50b0FycmF5KCkubWFwKHQgPT4gY3JlYXRlTm9kZUZyb21ZRWxlbWVudCgvKiogQHR5cGUge1kuWG1sRWxlbWVudH0gKi8gKHQpLCB0aGlzLnByb3NlbWlycm9yVmlldy5zdGF0ZS5zY2hlbWEsIHRoaXMubWFwcGluZykpLmZpbHRlcihuID0+IG4gIT09IG51bGwpXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb25zdCB0ciA9IHRoaXMuX3RyLnJlcGxhY2UoMCwgdGhpcy5wcm9zZW1pcnJvclZpZXcuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZSwgbmV3IFBNb2RlbC5TbGljZShuZXcgUE1vZGVsLkZyYWdtZW50KGZyYWdtZW50Q29udGVudCksIDAsIDApKVxuICAgICAgdHIuc2V0TWV0YSh5U3luY1BsdWdpbktleSwgeyBzbmFwc2hvdDogbnVsbCwgcHJldlNuYXBzaG90OiBudWxsIH0pXG4gICAgICB0aGlzLnByb3NlbWlycm9yVmlldy5kaXNwYXRjaCh0cilcbiAgICB9KVxuICB9XG5cbiAgX2ZvcmNlUmVyZW5kZXIgKCkge1xuICAgIHRoaXMubWFwcGluZyA9IG5ldyBNYXAoKVxuICAgIHRoaXMubXV4KCgpID0+IHtcbiAgICAgIGNvbnN0IGZyYWdtZW50Q29udGVudCA9IHRoaXMudHlwZS50b0FycmF5KCkubWFwKHQgPT4gY3JlYXRlTm9kZUZyb21ZRWxlbWVudCgvKiogQHR5cGUge1kuWG1sRWxlbWVudH0gKi8gKHQpLCB0aGlzLnByb3NlbWlycm9yVmlldy5zdGF0ZS5zY2hlbWEsIHRoaXMubWFwcGluZykpLmZpbHRlcihuID0+IG4gIT09IG51bGwpXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb25zdCB0ciA9IHRoaXMuX3RyLnJlcGxhY2UoMCwgdGhpcy5wcm9zZW1pcnJvclZpZXcuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZSwgbmV3IFBNb2RlbC5TbGljZShuZXcgUE1vZGVsLkZyYWdtZW50KGZyYWdtZW50Q29udGVudCksIDAsIDApKVxuICAgICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuZGlzcGF0Y2godHIuc2V0TWV0YSh5U3luY1BsdWdpbktleSwgeyBpc0NoYW5nZU9yaWdpbjogdHJ1ZSB9KSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7WS5TbmFwc2hvdH0gc25hcHNob3RcbiAgICogQHBhcmFtIHtZLlNuYXBzaG90fSBwcmV2U25hcHNob3RcbiAgICogQHBhcmFtIHtPYmplY3R9IHBsdWdpblN0YXRlXG4gICAqL1xuICBfcmVuZGVyU25hcHNob3QgKHNuYXBzaG90LCBwcmV2U25hcHNob3QsIHBsdWdpblN0YXRlKSB7XG4gICAgaWYgKCFzbmFwc2hvdCkge1xuICAgICAgc25hcHNob3QgPSBZLnNuYXBzaG90KHRoaXMuZG9jKVxuICAgIH1cbiAgICAvLyBjbGVhciBtYXBwaW5nIGJlY2F1c2Ugd2UgYXJlIGdvaW5nIHRvIHJlcmVuZGVyXG4gICAgdGhpcy5tYXBwaW5nID0gbmV3IE1hcCgpXG4gICAgdGhpcy5tdXgoKCkgPT4ge1xuICAgICAgdGhpcy5kb2MudHJhbnNhY3QodHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICAvLyBiZWZvcmUgcmVuZGVyaW5nLCB3ZSBhcmUgZ29pbmcgdG8gc2FuaXRpemUgb3BzIGFuZCBzcGxpdCBkZWxldGVkIG9wc1xuICAgICAgICAvLyBpZiB0aGV5IHdlcmUgZGVsZXRlZCBieSBzZXBlcmF0ZSB1c2Vycy5cbiAgICAgICAgY29uc3QgcHVkID0gcGx1Z2luU3RhdGUucGVybWFuZW50VXNlckRhdGFcbiAgICAgICAgaWYgKHB1ZCkge1xuICAgICAgICAgIHB1ZC5kc3MuZm9yRWFjaChkcyA9PiB7XG4gICAgICAgICAgICBZLml0ZXJhdGVEZWxldGVkU3RydWN0cyh0cmFuc2FjdGlvbiwgZHMsIGl0ZW0gPT4ge30pXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21wdXRlWUNoYW5nZSA9ICh0eXBlLCBpZCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHVzZXIgPSB0eXBlID09PSAnYWRkZWQnID8gcHVkLmdldFVzZXJCeUNsaWVudElkKGlkLmNsaWVudCkgOiBwdWQuZ2V0VXNlckJ5RGVsZXRlZElkKGlkKVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1c2VyLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIGNvbG9yOiBnZXRVc2VyQ29sb3IocGx1Z2luU3RhdGUuY29sb3JNYXBwaW5nLCBwbHVnaW5TdGF0ZS5jb2xvcnMsIHVzZXIpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBkb2N1bWVudCBmcmFnbWVudCBhbmQgcmVuZGVyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50Q29udGVudCA9IFkudHlwZUxpc3RUb0FycmF5U25hcHNob3QodGhpcy50eXBlLCBuZXcgWS5TbmFwc2hvdChwcmV2U25hcHNob3QuZHMsIHNuYXBzaG90LnN2KSkubWFwKHQgPT4ge1xuICAgICAgICAgIGlmICghdC5faXRlbS5kZWxldGVkIHx8IGlzVmlzaWJsZSh0Ll9pdGVtLCBzbmFwc2hvdCkgfHwgaXNWaXNpYmxlKHQuX2l0ZW0sIHByZXZTbmFwc2hvdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVOb2RlRnJvbVlFbGVtZW50KHQsIHRoaXMucHJvc2VtaXJyb3JWaWV3LnN0YXRlLnNjaGVtYSwgbmV3IE1hcCgpLCBzbmFwc2hvdCwgcHJldlNuYXBzaG90LCBjb21wdXRlWUNoYW5nZSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byByZW5kZXIgZWxlbWVudHMgdGhhdCBhcmUgbm90IHZpc2libGUgYnkgZWl0aGVyIHNuYXBzaG90LlxuICAgICAgICAgICAgLy8gSWYgYSBjbGllbnQgYWRkcyBhbmQgZGVsZXRlcyBjb250ZW50IGluIHRoZSBzYW1lIHNuYXBzaG90IHRoZSBlbGVtZW50IGlzIG5vdCB2aXNpYmxlIGJ5IGVpdGhlciBzbmFwc2hvdC5cbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgfVxuICAgICAgICB9KS5maWx0ZXIobiA9PiBuICE9PSBudWxsKVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNvbnN0IHRyID0gdGhpcy5fdHIucmVwbGFjZSgwLCB0aGlzLnByb3NlbWlycm9yVmlldy5zdGF0ZS5kb2MuY29udGVudC5zaXplLCBuZXcgUE1vZGVsLlNsaWNlKG5ldyBQTW9kZWwuRnJhZ21lbnQoZnJhZ21lbnRDb250ZW50KSwgMCwgMCkpXG4gICAgICAgIHRoaXMucHJvc2VtaXJyb3JWaWV3LmRpc3BhdGNoKHRyLnNldE1ldGEoeVN5bmNQbHVnaW5LZXksIHsgaXNDaGFuZ2VPcmlnaW46IHRydWUgfSkpXG4gICAgICB9LCB5U3luY1BsdWdpbktleSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8WS5ZRXZlbnQ8YW55Pj59IGV2ZW50c1xuICAgKiBAcGFyYW0ge1kuVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqL1xuICBfdHlwZUNoYW5nZWQgKGV2ZW50cywgdHJhbnNhY3Rpb24pIHtcbiAgICBjb25zdCBzeW5jU3RhdGUgPSB5U3luY1BsdWdpbktleS5nZXRTdGF0ZSh0aGlzLnByb3NlbWlycm9yVmlldy5zdGF0ZSlcbiAgICBpZiAoZXZlbnRzLmxlbmd0aCA9PT0gMCB8fCBzeW5jU3RhdGUuc25hcHNob3QgIT0gbnVsbCB8fCBzeW5jU3RhdGUucHJldlNuYXBzaG90ICE9IG51bGwpIHtcbiAgICAgIC8vIGRyb3Agb3V0IGlmIHNuYXBzaG90IGlzIGFjdGl2ZVxuICAgICAgdGhpcy5yZW5kZXJTbmFwc2hvdChzeW5jU3RhdGUuc25hcHNob3QsIHN5bmNTdGF0ZS5wcmV2U25hcHNob3QpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5tdXgoKCkgPT4ge1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge2FueX0gX1xuICAgICAgICogQHBhcmFtIHtZLkFic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGRlbFR5cGUgPSAoXywgdHlwZSkgPT4gdGhpcy5tYXBwaW5nLmRlbGV0ZSh0eXBlKVxuICAgICAgWS5pdGVyYXRlRGVsZXRlZFN0cnVjdHModHJhbnNhY3Rpb24sIHRyYW5zYWN0aW9uLmRlbGV0ZVNldCwgc3RydWN0ID0+IHN0cnVjdC5jb25zdHJ1Y3RvciA9PT0gWS5JdGVtICYmIHRoaXMubWFwcGluZy5kZWxldGUoLyoqIEB0eXBlIHtZLkNvbnRlbnRUeXBlfSAqLyAoLyoqIEB0eXBlIHtZLkl0ZW19ICovIChzdHJ1Y3QpLmNvbnRlbnQpLnR5cGUpKVxuICAgICAgdHJhbnNhY3Rpb24uY2hhbmdlZC5mb3JFYWNoKGRlbFR5cGUpXG4gICAgICB0cmFuc2FjdGlvbi5jaGFuZ2VkUGFyZW50VHlwZXMuZm9yRWFjaChkZWxUeXBlKVxuICAgICAgY29uc3QgZnJhZ21lbnRDb250ZW50ID0gdGhpcy50eXBlLnRvQXJyYXkoKS5tYXAodCA9PiBjcmVhdGVOb2RlSWZOb3RFeGlzdHMoLyoqIEB0eXBlIHtZLlhtbEVsZW1lbnQgfCBZLlhtbEhvb2t9ICovICh0KSwgdGhpcy5wcm9zZW1pcnJvclZpZXcuc3RhdGUuc2NoZW1hLCB0aGlzLm1hcHBpbmcpKS5maWx0ZXIobiA9PiBuICE9PSBudWxsKVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgbGV0IHRyID0gdGhpcy5fdHIucmVwbGFjZSgwLCB0aGlzLnByb3NlbWlycm9yVmlldy5zdGF0ZS5kb2MuY29udGVudC5zaXplLCBuZXcgUE1vZGVsLlNsaWNlKG5ldyBQTW9kZWwuRnJhZ21lbnQoZnJhZ21lbnRDb250ZW50KSwgMCwgMCkpXG4gICAgICByZXN0b3JlUmVsYXRpdmVTZWxlY3Rpb24odHIsIHRoaXMuYmVmb3JlVHJhbnNhY3Rpb25TZWxlY3Rpb24sIHRoaXMpXG4gICAgICB0ciA9IHRyLnNldE1ldGEoeVN5bmNQbHVnaW5LZXksIHsgaXNDaGFuZ2VPcmlnaW46IHRydWUgfSlcbiAgICAgIGlmICh0aGlzLmJlZm9yZVRyYW5zYWN0aW9uU2VsZWN0aW9uICE9PSBudWxsICYmIHRoaXMuX2lzTG9jYWxDdXJzb3JJblZpZXcoKSkge1xuICAgICAgICB0ci5zY3JvbGxJbnRvVmlldygpXG4gICAgICB9XG4gICAgICB0aGlzLnByb3NlbWlycm9yVmlldy5kaXNwYXRjaCh0cilcbiAgICB9KVxuICB9XG5cbiAgX3Byb3NlbWlycm9yQ2hhbmdlZCAoZG9jKSB7XG4gICAgdGhpcy5tdXgoKCkgPT4ge1xuICAgICAgdGhpcy5kb2MudHJhbnNhY3QoKCkgPT4ge1xuICAgICAgICB1cGRhdGVZRnJhZ21lbnQodGhpcy5kb2MsIHRoaXMudHlwZSwgZG9jLCB0aGlzLm1hcHBpbmcpXG4gICAgICAgIHRoaXMuYmVmb3JlVHJhbnNhY3Rpb25TZWxlY3Rpb24gPSBnZXRSZWxhdGl2ZVNlbGVjdGlvbih0aGlzLCB0aGlzLnByb3NlbWlycm9yVmlldy5zdGF0ZSlcbiAgICAgIH0sIHlTeW5jUGx1Z2luS2V5KVxuICAgIH0pXG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLmlzRGVzdHJveWVkID0gdHJ1ZVxuICAgIHRoaXMudHlwZS51bm9ic2VydmVEZWVwKHRoaXMuX29ic2VydmVGdW5jdGlvbilcbiAgICB0aGlzLmRvYy5vZmYoJ2JlZm9yZUFsbFRyYW5zYWN0aW9ucycsIHRoaXMuYmVmb3JlQWxsVHJhbnNhY3Rpb25zKVxuICAgIHRoaXMuZG9jLm9mZignYWZ0ZXJBbGxUcmFuc2FjdGlvbnMnLCB0aGlzLmFmdGVyQWxsVHJhbnNhY3Rpb25zKVxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7WS5YbWxFbGVtZW50IHwgWS5YbWxIb29rfSBlbFxuICogQHBhcmFtIHtQTW9kZWwuU2NoZW1hfSBzY2hlbWFcbiAqIEBwYXJhbSB7UHJvc2VtaXJyb3JNYXBwaW5nfSBtYXBwaW5nXG4gKiBAcGFyYW0ge1kuU25hcHNob3R9IFtzbmFwc2hvdF1cbiAqIEBwYXJhbSB7WS5TbmFwc2hvdH0gW3ByZXZTbmFwc2hvdF1cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oJ3JlbW92ZWQnIHwgJ2FkZGVkJywgWS5JRCk6YW55fSBbY29tcHV0ZVlDaGFuZ2VdXG4gKiBAcmV0dXJuIHtQTW9kZWwuTm9kZSB8IG51bGx9XG4gKi9cbmNvbnN0IGNyZWF0ZU5vZGVJZk5vdEV4aXN0cyA9IChlbCwgc2NoZW1hLCBtYXBwaW5nLCBzbmFwc2hvdCwgcHJldlNuYXBzaG90LCBjb21wdXRlWUNoYW5nZSkgPT4ge1xuICBjb25zdCBub2RlID0gLyoqIEB0eXBlIHtQTW9kZWwuTm9kZX0gKi8gKG1hcHBpbmcuZ2V0KGVsKSlcbiAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChlbCBpbnN0YW5jZW9mIFkuWG1sRWxlbWVudCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZU5vZGVGcm9tWUVsZW1lbnQoZWwsIHNjaGVtYSwgbWFwcGluZywgc25hcHNob3QsIHByZXZTbmFwc2hvdCwgY29tcHV0ZVlDaGFuZ2UpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVycm9yLm1ldGhvZFVuaW1wbGVtZW50ZWQoKSAvLyB3ZSBhcmUgY3VycmVudGx5IG5vdCBoYW5kbGluZyBob29rc1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9kZVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1kuWG1sRWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7YW55fSBzY2hlbWFcbiAqIEBwYXJhbSB7UHJvc2VtaXJyb3JNYXBwaW5nfSBtYXBwaW5nXG4gKiBAcGFyYW0ge1kuU25hcHNob3R9IFtzbmFwc2hvdF1cbiAqIEBwYXJhbSB7WS5TbmFwc2hvdH0gW3ByZXZTbmFwc2hvdF1cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oJ3JlbW92ZWQnIHwgJ2FkZGVkJywgWS5JRCk6YW55fSBbY29tcHV0ZVlDaGFuZ2VdXG4gKiBAcmV0dXJuIHtQTW9kZWwuTm9kZSB8IG51bGx9IFJldHVybnMgbm9kZSBpZiBub2RlIGNvdWxkIGJlIGNyZWF0ZWQuIE90aGVyd2lzZSBpdCBkZWxldGVzIHRoZSB5anMgdHlwZSBhbmQgcmV0dXJucyBudWxsXG4gKi9cbmNvbnN0IGNyZWF0ZU5vZGVGcm9tWUVsZW1lbnQgPSAoZWwsIHNjaGVtYSwgbWFwcGluZywgc25hcHNob3QsIHByZXZTbmFwc2hvdCwgY29tcHV0ZVlDaGFuZ2UpID0+IHtcbiAgY29uc3QgY2hpbGRyZW4gPSBbXVxuICBjb25zdCBjcmVhdGVDaGlsZHJlbiA9IHR5cGUgPT4ge1xuICAgIGlmICh0eXBlLmNvbnN0cnVjdG9yID09PSBZLlhtbEVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IG4gPSBjcmVhdGVOb2RlSWZOb3RFeGlzdHModHlwZSwgc2NoZW1hLCBtYXBwaW5nLCBzbmFwc2hvdCwgcHJldlNuYXBzaG90LCBjb21wdXRlWUNoYW5nZSlcbiAgICAgIGlmIChuICE9PSBudWxsKSB7XG4gICAgICAgIGNoaWxkcmVuLnB1c2gobilcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbnMgPSBjcmVhdGVUZXh0Tm9kZXNGcm9tWVRleHQodHlwZSwgc2NoZW1hLCBtYXBwaW5nLCBzbmFwc2hvdCwgcHJldlNuYXBzaG90LCBjb21wdXRlWUNoYW5nZSlcbiAgICAgIGlmIChucyAhPT0gbnVsbCkge1xuICAgICAgICBucy5mb3JFYWNoKHRleHRjaGlsZCA9PiB7XG4gICAgICAgICAgaWYgKHRleHRjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0ZXh0Y2hpbGQpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoc25hcHNob3QgPT09IHVuZGVmaW5lZCB8fCBwcmV2U25hcHNob3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGVsLnRvQXJyYXkoKS5mb3JFYWNoKGNyZWF0ZUNoaWxkcmVuKVxuICB9IGVsc2Uge1xuICAgIFkudHlwZUxpc3RUb0FycmF5U25hcHNob3QoZWwsIG5ldyBZLlNuYXBzaG90KHByZXZTbmFwc2hvdC5kcywgc25hcHNob3Quc3YpKS5mb3JFYWNoKGNyZWF0ZUNoaWxkcmVuKVxuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgYXR0cnMgPSBlbC5nZXRBdHRyaWJ1dGVzKHNuYXBzaG90KVxuICAgIGlmIChzbmFwc2hvdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIWlzVmlzaWJsZSgvKiogQHR5cGUge1kuSXRlbX0gKi8gKGVsLl9pdGVtKSwgc25hcHNob3QpKSB7XG4gICAgICAgIGF0dHJzLnljaGFuZ2UgPSBjb21wdXRlWUNoYW5nZSA/IGNvbXB1dGVZQ2hhbmdlKCdyZW1vdmVkJywgLyoqIEB0eXBlIHtZLkl0ZW19ICovIChlbC5faXRlbSkuaWQpIDogeyB0eXBlOiAncmVtb3ZlZCcgfVxuICAgICAgfSBlbHNlIGlmICghaXNWaXNpYmxlKC8qKiBAdHlwZSB7WS5JdGVtfSAqLyAoZWwuX2l0ZW0pLCBwcmV2U25hcHNob3QpKSB7XG4gICAgICAgIGF0dHJzLnljaGFuZ2UgPSBjb21wdXRlWUNoYW5nZSA/IGNvbXB1dGVZQ2hhbmdlKCdhZGRlZCcsIC8qKiBAdHlwZSB7WS5JdGVtfSAqLyAoZWwuX2l0ZW0pLmlkKSA6IHsgdHlwZTogJ2FkZGVkJyB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSBzY2hlbWEubm9kZShlbC5ub2RlTmFtZSwgYXR0cnMsIGNoaWxkcmVuKVxuICAgIG1hcHBpbmcuc2V0KGVsLCBub2RlKVxuICAgIHJldHVybiBub2RlXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBhbiBlcnJvciBvY2N1cmVkIHdoaWxlIGNyZWF0aW5nIHRoZSBub2RlLiBUaGlzIGlzIHByb2JhYmx5IGEgcmVzdWx0IG9mIGEgY29uY3VycmVudCBhY3Rpb24uXG4gICAgLyoqIEB0eXBlIHtZLkRvY30gKi8gKGVsLmRvYykudHJhbnNhY3QodHJhbnNhY3Rpb24gPT4ge1xuICAgICAgLyoqIEB0eXBlIHtZLkl0ZW19ICovIChlbC5faXRlbSkuZGVsZXRlKHRyYW5zYWN0aW9uKVxuICAgIH0sIHlTeW5jUGx1Z2luS2V5KVxuICAgIG1hcHBpbmcuZGVsZXRlKGVsKVxuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtZLlhtbFRleHR9IHRleHRcbiAqIEBwYXJhbSB7YW55fSBzY2hlbWFcbiAqIEBwYXJhbSB7UHJvc2VtaXJyb3JNYXBwaW5nfSBtYXBwaW5nXG4gKiBAcGFyYW0ge1kuU25hcHNob3R9IFtzbmFwc2hvdF1cbiAqIEBwYXJhbSB7WS5TbmFwc2hvdH0gW3ByZXZTbmFwc2hvdF1cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oJ3JlbW92ZWQnIHwgJ2FkZGVkJywgWS5JRCk6YW55fSBbY29tcHV0ZVlDaGFuZ2VdXG4gKiBAcmV0dXJuIHtBcnJheTxQTW9kZWwuTm9kZT58bnVsbH1cbiAqL1xuY29uc3QgY3JlYXRlVGV4dE5vZGVzRnJvbVlUZXh0ID0gKHRleHQsIHNjaGVtYSwgbWFwcGluZywgc25hcHNob3QsIHByZXZTbmFwc2hvdCwgY29tcHV0ZVlDaGFuZ2UpID0+IHtcbiAgY29uc3Qgbm9kZXMgPSBbXVxuICBjb25zdCBkZWx0YXMgPSB0ZXh0LnRvRGVsdGEoc25hcHNob3QsIHByZXZTbmFwc2hvdCwgY29tcHV0ZVlDaGFuZ2UpXG4gIHRyeSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWx0YXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGRlbHRhID0gZGVsdGFzW2ldXG4gICAgICBjb25zdCBtYXJrcyA9IFtdXG4gICAgICBmb3IgKGNvbnN0IG1hcmtOYW1lIGluIGRlbHRhLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgbWFya3MucHVzaChzY2hlbWEubWFyayhtYXJrTmFtZSwgZGVsdGEuYXR0cmlidXRlc1ttYXJrTmFtZV0pKVxuICAgICAgfVxuICAgICAgbm9kZXMucHVzaChzY2hlbWEudGV4dChkZWx0YS5pbnNlcnQsIG1hcmtzKSlcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBhbiBlcnJvciBvY2N1cmVkIHdoaWxlIGNyZWF0aW5nIHRoZSBub2RlLiBUaGlzIGlzIHByb2JhYmx5IGEgcmVzdWx0IG9mIGEgY29uY3VycmVudCBhY3Rpb24uXG4gICAgLyoqIEB0eXBlIHtZLkRvY30gKi8gKHRleHQuZG9jKS50cmFuc2FjdCh0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAvKiogQHR5cGUge1kuSXRlbX0gKi8gKHRleHQuX2l0ZW0pLmRlbGV0ZSh0cmFuc2FjdGlvbilcbiAgICB9LCB5U3luY1BsdWdpbktleSlcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIC8vIEB0cy1pZ25vcmVcbiAgcmV0dXJuIG5vZGVzXG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gbm9kZXMgcHJvc2VtaXJyb3Igbm9kZVxuICogQHBhcmFtIHtQcm9zZW1pcnJvck1hcHBpbmd9IG1hcHBpbmdcbiAqIEByZXR1cm4ge1kuWG1sVGV4dH1cbiAqL1xuY29uc3QgY3JlYXRlVHlwZUZyb21UZXh0Tm9kZXMgPSAobm9kZXMsIG1hcHBpbmcpID0+IHtcbiAgY29uc3QgdHlwZSA9IG5ldyBZLlhtbFRleHQoKVxuICBjb25zdCBkZWx0YSA9IG5vZGVzLm1hcChub2RlID0+ICh7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGluc2VydDogbm9kZS50ZXh0LFxuICAgIGF0dHJpYnV0ZXM6IG1hcmtzVG9BdHRyaWJ1dGVzKG5vZGUubWFya3MpXG4gIH0pKVxuICB0eXBlLmFwcGx5RGVsdGEoZGVsdGEpXG4gIG1hcHBpbmcuc2V0KHR5cGUsIG5vZGVzKVxuICByZXR1cm4gdHlwZVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2FueX0gbm9kZSBwcm9zZW1pcnJvciBub2RlXG4gKiBAcGFyYW0ge1Byb3NlbWlycm9yTWFwcGluZ30gbWFwcGluZ1xuICogQHJldHVybiB7WS5YbWxFbGVtZW50fVxuICovXG5jb25zdCBjcmVhdGVUeXBlRnJvbUVsZW1lbnROb2RlID0gKG5vZGUsIG1hcHBpbmcpID0+IHtcbiAgY29uc3QgdHlwZSA9IG5ldyBZLlhtbEVsZW1lbnQobm9kZS50eXBlLm5hbWUpXG4gIGZvciAoY29uc3Qga2V5IGluIG5vZGUuYXR0cnMpIHtcbiAgICBjb25zdCB2YWwgPSBub2RlLmF0dHJzW2tleV1cbiAgICBpZiAodmFsICE9PSBudWxsICYmIGtleSAhPT0gJ3ljaGFuZ2UnKSB7XG4gICAgICB0eXBlLnNldEF0dHJpYnV0ZShrZXksIHZhbClcbiAgICB9XG4gIH1cbiAgdHlwZS5pbnNlcnQoMCwgbm9ybWFsaXplUE5vZGVDb250ZW50KG5vZGUpLm1hcChuID0+IGNyZWF0ZVR5cGVGcm9tVGV4dE9yRWxlbWVudE5vZGUobiwgbWFwcGluZykpKVxuICBtYXBwaW5nLnNldCh0eXBlLCBub2RlKVxuICByZXR1cm4gdHlwZVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1BNb2RlbC5Ob2RlfEFycmF5PFBNb2RlbC5Ob2RlPn0gbm9kZSBwcm9zZW1pcnJvciB0ZXh0IG5vZGVcbiAqIEBwYXJhbSB7UHJvc2VtaXJyb3JNYXBwaW5nfSBtYXBwaW5nXG4gKiBAcmV0dXJuIHtZLlhtbEVsZW1lbnR8WS5YbWxUZXh0fVxuICovXG5jb25zdCBjcmVhdGVUeXBlRnJvbVRleHRPckVsZW1lbnROb2RlID0gKG5vZGUsIG1hcHBpbmcpID0+IG5vZGUgaW5zdGFuY2VvZiBBcnJheSA/IGNyZWF0ZVR5cGVGcm9tVGV4dE5vZGVzKG5vZGUsIG1hcHBpbmcpIDogY3JlYXRlVHlwZUZyb21FbGVtZW50Tm9kZShub2RlLCBtYXBwaW5nKVxuXG5jb25zdCBpc09iamVjdCA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbFxuXG5jb25zdCBlcXVhbEF0dHJzID0gKHBhdHRycywgeWF0dHJzKSA9PiB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwYXR0cnMpLmZpbHRlcihrZXkgPT4gcGF0dHJzW2tleV0gIT09IG51bGwpXG4gIGxldCBlcSA9IGtleXMubGVuZ3RoID09PSBPYmplY3Qua2V5cyh5YXR0cnMpLmZpbHRlcihrZXkgPT4geWF0dHJzW2tleV0gIT09IG51bGwpLmxlbmd0aFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoICYmIGVxOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldXG4gICAgY29uc3QgbCA9IHBhdHRyc1trZXldXG4gICAgY29uc3QgciA9IHlhdHRyc1trZXldXG4gICAgZXEgPSBrZXkgPT09ICd5Y2hhbmdlJyB8fCBsID09PSByIHx8IChpc09iamVjdChsKSAmJiBpc09iamVjdChyKSAmJiBlcXVhbEF0dHJzKGwsIHIpKVxuICB9XG4gIHJldHVybiBlcVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtBcnJheTxBcnJheTxQTW9kZWwuTm9kZT58UE1vZGVsLk5vZGU+fSBOb3JtYWxpemVkUE5vZGVDb250ZW50XG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gcG5vZGVcbiAqIEByZXR1cm4ge05vcm1hbGl6ZWRQTm9kZUNvbnRlbnR9XG4gKi9cbmNvbnN0IG5vcm1hbGl6ZVBOb2RlQ29udGVudCA9IHBub2RlID0+IHtcbiAgY29uc3QgYyA9IHBub2RlLmNvbnRlbnQuY29udGVudFxuICBjb25zdCByZXMgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBuID0gY1tpXVxuICAgIGlmIChuLmlzVGV4dCkge1xuICAgICAgY29uc3QgdGV4dE5vZGVzID0gW11cbiAgICAgIGZvciAobGV0IHRub2RlID0gY1tpXTsgaSA8IGMubGVuZ3RoICYmIHRub2RlLmlzVGV4dDsgdG5vZGUgPSBjWysraV0pIHtcbiAgICAgICAgdGV4dE5vZGVzLnB1c2godG5vZGUpXG4gICAgICB9XG4gICAgICBpLS1cbiAgICAgIHJlcy5wdXNoKHRleHROb2RlcylcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzLnB1c2gobilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKipcbiAqIEBwYXJhbSB7WS5YbWxUZXh0fSB5dGV4dFxuICogQHBhcmFtIHtBcnJheTxhbnk+fSBwdGV4dHNcbiAqL1xuY29uc3QgZXF1YWxZVGV4dFBUZXh0ID0gKHl0ZXh0LCBwdGV4dHMpID0+IHtcbiAgY29uc3QgZGVsdGEgPSB5dGV4dC50b0RlbHRhKClcbiAgcmV0dXJuIGRlbHRhLmxlbmd0aCA9PT0gcHRleHRzLmxlbmd0aCAmJiBkZWx0YS5ldmVyeSgoZCwgaSkgPT4gZC5pbnNlcnQgPT09IC8qKiBAdHlwZSB7YW55fSAqLyAocHRleHRzW2ldKS50ZXh0ICYmIG9iamVjdC5rZXlzKGQuYXR0cmlidXRlcyB8fCB7fSkubGVuZ3RoID09PSBwdGV4dHNbaV0ubWFya3MubGVuZ3RoICYmIHB0ZXh0c1tpXS5tYXJrcy5ldmVyeShtYXJrID0+IGVxdWFsQXR0cnMoZC5hdHRyaWJ1dGVzW21hcmsudHlwZS5uYW1lXSB8fCB7fSwgbWFyay5hdHRycykpKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7WS5YbWxFbGVtZW50fFkuWG1sVGV4dHxZLlhtbEhvb2t9IHl0eXBlXG4gKiBAcGFyYW0ge2FueXxBcnJheTxhbnk+fSBwbm9kZVxuICovXG5jb25zdCBlcXVhbFlUeXBlUE5vZGUgPSAoeXR5cGUsIHBub2RlKSA9PiB7XG4gIGlmICh5dHlwZSBpbnN0YW5jZW9mIFkuWG1sRWxlbWVudCAmJiAhKHBub2RlIGluc3RhbmNlb2YgQXJyYXkpICYmIG1hdGNoTm9kZU5hbWUoeXR5cGUsIHBub2RlKSkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRDb250ZW50ID0gbm9ybWFsaXplUE5vZGVDb250ZW50KHBub2RlKVxuICAgIHJldHVybiB5dHlwZS5fbGVuZ3RoID09PSBub3JtYWxpemVkQ29udGVudC5sZW5ndGggJiYgZXF1YWxBdHRycyh5dHlwZS5nZXRBdHRyaWJ1dGVzKCksIHBub2RlLmF0dHJzKSAmJiB5dHlwZS50b0FycmF5KCkuZXZlcnkoKHljaGlsZCwgaSkgPT4gZXF1YWxZVHlwZVBOb2RlKHljaGlsZCwgbm9ybWFsaXplZENvbnRlbnRbaV0pKVxuICB9XG4gIHJldHVybiB5dHlwZSBpbnN0YW5jZW9mIFkuWG1sVGV4dCAmJiBwbm9kZSBpbnN0YW5jZW9mIEFycmF5ICYmIGVxdWFsWVRleHRQVGV4dCh5dHlwZSwgcG5vZGUpXG59XG5cbi8qKlxuICogQHBhcmFtIHtQTW9kZWwuTm9kZSB8IEFycmF5PFBNb2RlbC5Ob2RlPiB8IHVuZGVmaW5lZH0gbWFwcGVkXG4gKiBAcGFyYW0ge1BNb2RlbC5Ob2RlIHwgQXJyYXk8UE1vZGVsLk5vZGU+fSBwY29udGVudFxuICovXG5jb25zdCBtYXBwZWRJZGVudGl0eSA9IChtYXBwZWQsIHBjb250ZW50KSA9PiBtYXBwZWQgPT09IHBjb250ZW50IHx8IChtYXBwZWQgaW5zdGFuY2VvZiBBcnJheSAmJiBwY29udGVudCBpbnN0YW5jZW9mIEFycmF5ICYmIG1hcHBlZC5sZW5ndGggPT09IHBjb250ZW50Lmxlbmd0aCAmJiBtYXBwZWQuZXZlcnkoKGEsIGkpID0+IHBjb250ZW50W2ldID09PSBhKSlcblxuLyoqXG4gKiBAcGFyYW0ge1kuWG1sRWxlbWVudH0geXR5cGVcbiAqIEBwYXJhbSB7UE1vZGVsLk5vZGV9IHBub2RlXG4gKiBAcGFyYW0ge1Byb3NlbWlycm9yTWFwcGluZ30gbWFwcGluZ1xuICogQHJldHVybiB7eyBmb3VuZE1hcHBlZENoaWxkOiBib29sZWFuLCBlcXVhbGl0eUZhY3RvcjogbnVtYmVyIH19XG4gKi9cbmNvbnN0IGNvbXB1dGVDaGlsZEVxdWFsaXR5RmFjdG9yID0gKHl0eXBlLCBwbm9kZSwgbWFwcGluZykgPT4ge1xuICBjb25zdCB5Q2hpbGRyZW4gPSB5dHlwZS50b0FycmF5KClcbiAgY29uc3QgcENoaWxkcmVuID0gbm9ybWFsaXplUE5vZGVDb250ZW50KHBub2RlKVxuICBjb25zdCBwQ2hpbGRDbnQgPSBwQ2hpbGRyZW4ubGVuZ3RoXG4gIGNvbnN0IHlDaGlsZENudCA9IHlDaGlsZHJlbi5sZW5ndGhcbiAgY29uc3QgbWluQ250ID0gbWF0aC5taW4oeUNoaWxkQ250LCBwQ2hpbGRDbnQpXG4gIGxldCBsZWZ0ID0gMFxuICBsZXQgcmlnaHQgPSAwXG4gIGxldCBmb3VuZE1hcHBlZENoaWxkID0gZmFsc2VcbiAgZm9yICg7IGxlZnQgPCBtaW5DbnQ7IGxlZnQrKykge1xuICAgIGNvbnN0IGxlZnRZID0geUNoaWxkcmVuW2xlZnRdXG4gICAgY29uc3QgbGVmdFAgPSBwQ2hpbGRyZW5bbGVmdF1cbiAgICBpZiAobWFwcGVkSWRlbnRpdHkobWFwcGluZy5nZXQobGVmdFkpLCBsZWZ0UCkpIHtcbiAgICAgIGZvdW5kTWFwcGVkQ2hpbGQgPSB0cnVlLy8gZGVmaW5pdGUgKGdvb2QpIG1hdGNoIVxuICAgIH0gZWxzZSBpZiAoIWVxdWFsWVR5cGVQTm9kZShsZWZ0WSwgbGVmdFApKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICBmb3IgKDsgbGVmdCArIHJpZ2h0IDwgbWluQ250OyByaWdodCsrKSB7XG4gICAgY29uc3QgcmlnaHRZID0geUNoaWxkcmVuW3lDaGlsZENudCAtIHJpZ2h0IC0gMV1cbiAgICBjb25zdCByaWdodFAgPSBwQ2hpbGRyZW5bcENoaWxkQ250IC0gcmlnaHQgLSAxXVxuICAgIGlmIChtYXBwZWRJZGVudGl0eShtYXBwaW5nLmdldChyaWdodFkpLCByaWdodFApKSB7XG4gICAgICBmb3VuZE1hcHBlZENoaWxkID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoIWVxdWFsWVR5cGVQTm9kZShyaWdodFksIHJpZ2h0UCkpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgZXF1YWxpdHlGYWN0b3I6IGxlZnQgKyByaWdodCxcbiAgICBmb3VuZE1hcHBlZENoaWxkXG4gIH1cbn1cblxuY29uc3QgeXRleHRUcmFucyA9IHl0ZXh0ID0+IHtcbiAgbGV0IHN0ciA9ICcnXG4gIC8qKlxuICAgKiBAdHlwZSB7WS5JdGVtfG51bGx9XG4gICAqL1xuICBsZXQgbiA9IHl0ZXh0Ll9zdGFydFxuICBjb25zdCBuQXR0cnMgPSB7fVxuICB3aGlsZSAobiAhPT0gbnVsbCkge1xuICAgIGlmICghbi5kZWxldGVkKSB7XG4gICAgICBpZiAobi5jb3VudGFibGUgJiYgbi5jb250ZW50IGluc3RhbmNlb2YgWS5Db250ZW50U3RyaW5nKSB7XG4gICAgICAgIHN0ciArPSBuLmNvbnRlbnQuc3RyXG4gICAgICB9IGVsc2UgaWYgKG4uY29udGVudCBpbnN0YW5jZW9mIFkuQ29udGVudEZvcm1hdCkge1xuICAgICAgICBuQXR0cnNbbi5jb250ZW50LmtleV0gPSBudWxsXG4gICAgICB9XG4gICAgfVxuICAgIG4gPSBuLnJpZ2h0XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdHIsXG4gICAgbkF0dHJzXG4gIH1cbn1cblxuLyoqXG4gKiBAdG9kbyB0ZXN0IHRoaXMgbW9yZVxuICpcbiAqIEBwYXJhbSB7WS5UZXh0fSB5dGV4dFxuICogQHBhcmFtIHtBcnJheTxhbnk+fSBwdGV4dHNcbiAqIEBwYXJhbSB7UHJvc2VtaXJyb3JNYXBwaW5nfSBtYXBwaW5nXG4gKi9cbmNvbnN0IHVwZGF0ZVlUZXh0ID0gKHl0ZXh0LCBwdGV4dHMsIG1hcHBpbmcpID0+IHtcbiAgbWFwcGluZy5zZXQoeXRleHQsIHB0ZXh0cylcbiAgY29uc3QgeyBuQXR0cnMsIHN0ciB9ID0geXRleHRUcmFucyh5dGV4dClcbiAgY29uc3QgY29udGVudCA9IHB0ZXh0cy5tYXAocCA9PiAoeyBpbnNlcnQ6IC8qKiBAdHlwZSB7YW55fSAqLyAocCkudGV4dCwgYXR0cmlidXRlczogT2JqZWN0LmFzc2lnbih7fSwgbkF0dHJzLCBtYXJrc1RvQXR0cmlidXRlcyhwLm1hcmtzKSkgfSkpXG4gIGNvbnN0IHsgaW5zZXJ0LCByZW1vdmUsIGluZGV4IH0gPSBzaW1wbGVEaWZmKHN0ciwgY29udGVudC5tYXAoYyA9PiBjLmluc2VydCkuam9pbignJykpXG4gIHl0ZXh0LmRlbGV0ZShpbmRleCwgcmVtb3ZlKVxuICB5dGV4dC5pbnNlcnQoaW5kZXgsIGluc2VydClcbiAgeXRleHQuYXBwbHlEZWx0YShjb250ZW50Lm1hcChjID0+ICh7IHJldGFpbjogYy5pbnNlcnQubGVuZ3RoLCBhdHRyaWJ1dGVzOiBjLmF0dHJpYnV0ZXMgfSkpKVxufVxuXG5jb25zdCBtYXJrc1RvQXR0cmlidXRlcyA9IG1hcmtzID0+IHtcbiAgY29uc3QgcGF0dHJzID0ge31cbiAgbWFya3MuZm9yRWFjaChtYXJrID0+IHtcbiAgICBpZiAobWFyay50eXBlLm5hbWUgIT09ICd5Y2hhbmdlJykge1xuICAgICAgcGF0dHJzW21hcmsudHlwZS5uYW1lXSA9IG1hcmsuYXR0cnNcbiAgICB9XG4gIH0pXG4gIHJldHVybiBwYXR0cnNcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHt7dHJhbnNhY3Q6IEZ1bmN0aW9ufX0geVxuICogQHBhcmFtIHtZLlhtbEZyYWdtZW50fSB5RG9tRnJhZ21lbnRcbiAqIEBwYXJhbSB7YW55fSBwTm9kZVxuICogQHBhcmFtIHtQcm9zZW1pcnJvck1hcHBpbmd9IG1hcHBpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IHVwZGF0ZVlGcmFnbWVudCA9ICh5LCB5RG9tRnJhZ21lbnQsIHBOb2RlLCBtYXBwaW5nKSA9PiB7XG4gIGlmICh5RG9tRnJhZ21lbnQgaW5zdGFuY2VvZiBZLlhtbEVsZW1lbnQgJiYgeURvbUZyYWdtZW50Lm5vZGVOYW1lICE9PSBwTm9kZS50eXBlLm5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vZGUgbmFtZSBtaXNtYXRjaCEnKVxuICB9XG4gIG1hcHBpbmcuc2V0KHlEb21GcmFnbWVudCwgcE5vZGUpXG4gIC8vIHVwZGF0ZSBhdHRyaWJ1dGVzXG4gIGlmICh5RG9tRnJhZ21lbnQgaW5zdGFuY2VvZiBZLlhtbEVsZW1lbnQpIHtcbiAgICBjb25zdCB5RG9tQXR0cnMgPSB5RG9tRnJhZ21lbnQuZ2V0QXR0cmlidXRlcygpXG4gICAgY29uc3QgcEF0dHJzID0gcE5vZGUuYXR0cnNcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwQXR0cnMpIHtcbiAgICAgIGlmIChwQXR0cnNba2V5XSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoeURvbUF0dHJzW2tleV0gIT09IHBBdHRyc1trZXldICYmIGtleSAhPT0gJ3ljaGFuZ2UnKSB7XG4gICAgICAgICAgeURvbUZyYWdtZW50LnNldEF0dHJpYnV0ZShrZXksIHBBdHRyc1trZXldKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5RG9tRnJhZ21lbnQucmVtb3ZlQXR0cmlidXRlKGtleSlcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcmVtb3ZlIGFsbCBrZXlzIHRoYXQgYXJlIG5vIGxvbmdlciBpbiBwQXR0cnNcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB5RG9tQXR0cnMpIHtcbiAgICAgIGlmIChwQXR0cnNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHlEb21GcmFnbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5KVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyB1cGRhdGUgY2hpbGRyZW5cbiAgY29uc3QgcENoaWxkcmVuID0gbm9ybWFsaXplUE5vZGVDb250ZW50KHBOb2RlKVxuICBjb25zdCBwQ2hpbGRDbnQgPSBwQ2hpbGRyZW4ubGVuZ3RoXG4gIGNvbnN0IHlDaGlsZHJlbiA9IHlEb21GcmFnbWVudC50b0FycmF5KClcbiAgY29uc3QgeUNoaWxkQ250ID0geUNoaWxkcmVuLmxlbmd0aFxuICBjb25zdCBtaW5DbnQgPSBtYXRoLm1pbihwQ2hpbGRDbnQsIHlDaGlsZENudClcbiAgbGV0IGxlZnQgPSAwXG4gIGxldCByaWdodCA9IDBcbiAgLy8gZmluZCBudW1iZXIgb2YgbWF0Y2hpbmcgZWxlbWVudHMgZnJvbSBsZWZ0XG4gIGZvciAoO2xlZnQgPCBtaW5DbnQ7IGxlZnQrKykge1xuICAgIGNvbnN0IGxlZnRZID0geUNoaWxkcmVuW2xlZnRdXG4gICAgY29uc3QgbGVmdFAgPSBwQ2hpbGRyZW5bbGVmdF1cbiAgICBpZiAoIW1hcHBlZElkZW50aXR5KG1hcHBpbmcuZ2V0KGxlZnRZKSwgbGVmdFApKSB7XG4gICAgICBpZiAoZXF1YWxZVHlwZVBOb2RlKGxlZnRZLCBsZWZ0UCkpIHtcbiAgICAgICAgLy8gdXBkYXRlIG1hcHBpbmdcbiAgICAgICAgbWFwcGluZy5zZXQobGVmdFksIGxlZnRQKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gZmluZCBudW1iZXIgb2YgbWF0Y2hpbmcgZWxlbWVudHMgZnJvbSByaWdodFxuICBmb3IgKDtyaWdodCArIGxlZnQgKyAxIDwgbWluQ250OyByaWdodCsrKSB7XG4gICAgY29uc3QgcmlnaHRZID0geUNoaWxkcmVuW3lDaGlsZENudCAtIHJpZ2h0IC0gMV1cbiAgICBjb25zdCByaWdodFAgPSBwQ2hpbGRyZW5bcENoaWxkQ250IC0gcmlnaHQgLSAxXVxuICAgIGlmICghbWFwcGVkSWRlbnRpdHkobWFwcGluZy5nZXQocmlnaHRZKSwgcmlnaHRQKSkge1xuICAgICAgaWYgKGVxdWFsWVR5cGVQTm9kZShyaWdodFksIHJpZ2h0UCkpIHtcbiAgICAgICAgLy8gdXBkYXRlIG1hcHBpbmdcbiAgICAgICAgbWFwcGluZy5zZXQocmlnaHRZLCByaWdodFApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB5LnRyYW5zYWN0KCgpID0+IHtcbiAgICAvLyB0cnkgdG8gY29tcGFyZSBhbmQgdXBkYXRlXG4gICAgd2hpbGUgKHlDaGlsZENudCAtIGxlZnQgLSByaWdodCA+IDAgJiYgcENoaWxkQ250IC0gbGVmdCAtIHJpZ2h0ID4gMCkge1xuICAgICAgY29uc3QgbGVmdFkgPSB5Q2hpbGRyZW5bbGVmdF1cbiAgICAgIGNvbnN0IGxlZnRQID0gcENoaWxkcmVuW2xlZnRdXG4gICAgICBjb25zdCByaWdodFkgPSB5Q2hpbGRyZW5beUNoaWxkQ250IC0gcmlnaHQgLSAxXVxuICAgICAgY29uc3QgcmlnaHRQID0gcENoaWxkcmVuW3BDaGlsZENudCAtIHJpZ2h0IC0gMV1cbiAgICAgIGlmIChsZWZ0WSBpbnN0YW5jZW9mIFkuWG1sVGV4dCAmJiBsZWZ0UCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGlmICghZXF1YWxZVGV4dFBUZXh0KGxlZnRZLCBsZWZ0UCkpIHtcbiAgICAgICAgICB1cGRhdGVZVGV4dChsZWZ0WSwgbGVmdFAsIG1hcHBpbmcpXG4gICAgICAgIH1cbiAgICAgICAgbGVmdCArPSAxXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgdXBkYXRlTGVmdCA9IGxlZnRZIGluc3RhbmNlb2YgWS5YbWxFbGVtZW50ICYmIG1hdGNoTm9kZU5hbWUobGVmdFksIGxlZnRQKVxuICAgICAgICBsZXQgdXBkYXRlUmlnaHQgPSByaWdodFkgaW5zdGFuY2VvZiBZLlhtbEVsZW1lbnQgJiYgbWF0Y2hOb2RlTmFtZShyaWdodFksIHJpZ2h0UClcbiAgICAgICAgaWYgKHVwZGF0ZUxlZnQgJiYgdXBkYXRlUmlnaHQpIHtcbiAgICAgICAgICAvLyBkZWNpZGUgd2hpY2ggd2hpY2ggZWxlbWVudCB0byB1cGRhdGVcbiAgICAgICAgICBjb25zdCBlcXVhbGl0eUxlZnQgPSBjb21wdXRlQ2hpbGRFcXVhbGl0eUZhY3RvcigvKiogQHR5cGUge1kuWG1sRWxlbWVudH0gKi8gKGxlZnRZKSwgLyoqIEB0eXBlIHtQTW9kZWwuTm9kZX0gKi8gKGxlZnRQKSwgbWFwcGluZylcbiAgICAgICAgICBjb25zdCBlcXVhbGl0eVJpZ2h0ID0gY29tcHV0ZUNoaWxkRXF1YWxpdHlGYWN0b3IoLyoqIEB0eXBlIHtZLlhtbEVsZW1lbnR9ICovIChyaWdodFkpLCAvKiogQHR5cGUge1BNb2RlbC5Ob2RlfSAqLyAocmlnaHRQKSwgbWFwcGluZylcbiAgICAgICAgICBpZiAoZXF1YWxpdHlMZWZ0LmZvdW5kTWFwcGVkQ2hpbGQgJiYgIWVxdWFsaXR5UmlnaHQuZm91bmRNYXBwZWRDaGlsZCkge1xuICAgICAgICAgICAgdXBkYXRlUmlnaHQgPSBmYWxzZVxuICAgICAgICAgIH0gZWxzZSBpZiAoIWVxdWFsaXR5TGVmdC5mb3VuZE1hcHBlZENoaWxkICYmIGVxdWFsaXR5UmlnaHQuZm91bmRNYXBwZWRDaGlsZCkge1xuICAgICAgICAgICAgdXBkYXRlTGVmdCA9IGZhbHNlXG4gICAgICAgICAgfSBlbHNlIGlmIChlcXVhbGl0eUxlZnQuZXF1YWxpdHlGYWN0b3IgPCBlcXVhbGl0eVJpZ2h0LmVxdWFsaXR5RmFjdG9yKSB7XG4gICAgICAgICAgICB1cGRhdGVMZWZ0ID0gZmFsc2VcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXBkYXRlUmlnaHQgPSBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlTGVmdCkge1xuICAgICAgICAgIHVwZGF0ZVlGcmFnbWVudCh5LCAvKiogQHR5cGUge1kuWG1sRnJhZ21lbnR9ICovIChsZWZ0WSksIC8qKiBAdHlwZSB7UE1vZGVsLk5vZGV9ICovIChsZWZ0UCksIG1hcHBpbmcpXG4gICAgICAgICAgbGVmdCArPSAxXG4gICAgICAgIH0gZWxzZSBpZiAodXBkYXRlUmlnaHQpIHtcbiAgICAgICAgICB1cGRhdGVZRnJhZ21lbnQoeSwgLyoqIEB0eXBlIHtZLlhtbEZyYWdtZW50fSAqLyAocmlnaHRZKSwgLyoqIEB0eXBlIHtQTW9kZWwuTm9kZX0gKi8gKHJpZ2h0UCksIG1hcHBpbmcpXG4gICAgICAgICAgcmlnaHQgKz0gMVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlEb21GcmFnbWVudC5kZWxldGUobGVmdCwgMSlcbiAgICAgICAgICB5RG9tRnJhZ21lbnQuaW5zZXJ0KGxlZnQsIFtjcmVhdGVUeXBlRnJvbVRleHRPckVsZW1lbnROb2RlKGxlZnRQLCBtYXBwaW5nKV0pXG4gICAgICAgICAgbGVmdCArPSAxXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeURlbExlbiA9IHlDaGlsZENudCAtIGxlZnQgLSByaWdodFxuICAgIGlmICh5Q2hpbGRDbnQgPT09IDEgJiYgcENoaWxkQ250ID09PSAwICYmIHlDaGlsZHJlblswXSBpbnN0YW5jZW9mIFkuWG1sVGV4dCkge1xuICAgICAgLy8gRWRnZSBjYXNlIGhhbmRsaW5nIGh0dHBzOi8vZ2l0aHViLmNvbS95anMveS1wcm9zZW1pcnJvci9pc3N1ZXMvMTA4XG4gICAgICAvLyBPbmx5IGRlbGV0ZSB0aGUgY29udGVudCBvZiB0aGUgWS5UZXh0IHRvIHJldGFpbiByZW1vdGUgY2hhbmdlcyBvbiB0aGUgc2FtZSBZLlRleHQgb2JqZWN0XG4gICAgICB5Q2hpbGRyZW5bMF0uZGVsZXRlKDAsIHlDaGlsZHJlblswXS5sZW5ndGgpXG4gICAgfSBlbHNlIGlmICh5RGVsTGVuID4gMCkge1xuICAgICAgeURvbUZyYWdtZW50LmRlbGV0ZShsZWZ0LCB5RGVsTGVuKVxuICAgIH1cbiAgICBpZiAobGVmdCArIHJpZ2h0IDwgcENoaWxkQ250KSB7XG4gICAgICBjb25zdCBpbnMgPSBbXVxuICAgICAgZm9yIChsZXQgaSA9IGxlZnQ7IGkgPCBwQ2hpbGRDbnQgLSByaWdodDsgaSsrKSB7XG4gICAgICAgIGlucy5wdXNoKGNyZWF0ZVR5cGVGcm9tVGV4dE9yRWxlbWVudE5vZGUocENoaWxkcmVuW2ldLCBtYXBwaW5nKSlcbiAgICAgIH1cbiAgICAgIHlEb21GcmFnbWVudC5pbnNlcnQobGVmdCwgaW5zKVxuICAgIH1cbiAgfSwgeVN5bmNQbHVnaW5LZXkpXG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1kuWG1sRWxlbWVudH0geUVsZW1lbnRcbiAqIEBwYXJhbSB7YW55fSBwTm9kZSBQcm9zZW1pcnJvciBOb2RlXG4gKi9cbmNvbnN0IG1hdGNoTm9kZU5hbWUgPSAoeUVsZW1lbnQsIHBOb2RlKSA9PiAhKHBOb2RlIGluc3RhbmNlb2YgQXJyYXkpICYmIHlFbGVtZW50Lm5vZGVOYW1lID09PSBwTm9kZS50eXBlLm5hbWVcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/y-prosemirror/src/plugins/sync-plugin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/y-prosemirror/src/plugins/undo-plugin.js":
/*!***************************************************************!*\
  !*** ./node_modules/y-prosemirror/src/plugins/undo-plugin.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultDeleteFilter: () => (/* binding */ defaultDeleteFilter),\n/* harmony export */   defaultProtectedNodes: () => (/* binding */ defaultProtectedNodes),\n/* harmony export */   redo: () => (/* binding */ redo),\n/* harmony export */   undo: () => (/* binding */ undo),\n/* harmony export */   yUndoPlugin: () => (/* binding */ yUndoPlugin)\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var _sync_plugin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sync-plugin.js */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/sync-plugin.js\");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! yjs */ \"(ssr)/./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./keys.js */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/keys.js\");\n\n // eslint-disable-line\n\n\n\n\n\nconst undo = state => {\n  const undoManager = _keys_js__WEBPACK_IMPORTED_MODULE_0__.yUndoPluginKey.getState(state).undoManager\n  if (undoManager != null) {\n    undoManager.undo()\n    return true\n  }\n}\n\nconst redo = state => {\n  const undoManager = _keys_js__WEBPACK_IMPORTED_MODULE_0__.yUndoPluginKey.getState(state).undoManager\n  if (undoManager != null) {\n    undoManager.redo()\n    return true\n  }\n}\n\nconst defaultProtectedNodes = new Set(['paragraph'])\n\nconst defaultDeleteFilter = (item, protectedNodes) => !(item instanceof yjs__WEBPACK_IMPORTED_MODULE_1__.Item) ||\n!(item.content instanceof yjs__WEBPACK_IMPORTED_MODULE_1__.ContentType) ||\n!(item.content.type instanceof yjs__WEBPACK_IMPORTED_MODULE_1__.Text ||\n  (item.content.type instanceof yjs__WEBPACK_IMPORTED_MODULE_1__.XmlElement && protectedNodes.has(item.content.type.nodeName))) ||\nitem.content.type._length === 0\n\nconst yUndoPlugin = ({ protectedNodes = defaultProtectedNodes, trackedOrigins = [], undoManager = null } = {}) => new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n  key: _keys_js__WEBPACK_IMPORTED_MODULE_0__.yUndoPluginKey,\n  state: {\n    init: (initargs, state) => {\n      // TODO: check if plugin order matches and fix\n      const ystate = _keys_js__WEBPACK_IMPORTED_MODULE_0__.ySyncPluginKey.getState(state)\n      const _undoManager = undoManager || new yjs__WEBPACK_IMPORTED_MODULE_1__.UndoManager(ystate.type, {\n        trackedOrigins: new Set([_keys_js__WEBPACK_IMPORTED_MODULE_0__.ySyncPluginKey].concat(trackedOrigins)),\n        deleteFilter: (item) => defaultDeleteFilter(item, protectedNodes)\n      })\n      return {\n        undoManager: _undoManager,\n        prevSel: null,\n        hasUndoOps: _undoManager.undoStack.length > 0,\n        hasRedoOps: _undoManager.redoStack.length > 0\n      }\n    },\n    apply: (tr, val, oldState, state) => {\n      const binding = _keys_js__WEBPACK_IMPORTED_MODULE_0__.ySyncPluginKey.getState(state).binding\n      const undoManager = val.undoManager\n      const hasUndoOps = undoManager.undoStack.length > 0\n      const hasRedoOps = undoManager.redoStack.length > 0\n      if (binding) {\n        return {\n          undoManager,\n          prevSel: (0,_sync_plugin_js__WEBPACK_IMPORTED_MODULE_3__.getRelativeSelection)(binding, oldState),\n          hasUndoOps,\n          hasRedoOps\n        }\n      } else {\n        if (hasUndoOps !== val.hasUndoOps || hasRedoOps !== val.hasRedoOps) {\n          return Object.assign({}, val, {\n            hasUndoOps: undoManager.undoStack.length > 0,\n            hasRedoOps: undoManager.redoStack.length > 0\n          })\n        } else { // nothing changed\n          return val\n        }\n      }\n    }\n  },\n  view: view => {\n    const ystate = _keys_js__WEBPACK_IMPORTED_MODULE_0__.ySyncPluginKey.getState(view.state)\n    const undoManager = _keys_js__WEBPACK_IMPORTED_MODULE_0__.yUndoPluginKey.getState(view.state).undoManager\n    undoManager.on('stack-item-added', ({ stackItem }) => {\n      const binding = ystate.binding\n      if (binding) {\n        stackItem.meta.set(binding, _keys_js__WEBPACK_IMPORTED_MODULE_0__.yUndoPluginKey.getState(view.state).prevSel)\n      }\n    })\n    undoManager.on('stack-item-popped', ({ stackItem }) => {\n      const binding = ystate.binding\n      if (binding) {\n        binding.beforeTransactionSelection = stackItem.meta.get(binding) || binding.beforeTransactionSelection\n      }\n    })\n    return {\n      destroy: () => {\n        undoManager.destroy()\n      }\n    }\n  }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveS1wcm9zZW1pcnJvci9zcmMvcGx1Z2lucy91bmRvLXBsdWdpbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQzBDOztBQUVhO0FBQ2U7QUFDWjs7QUFFbkQ7QUFDUCxzQkFBc0Isb0RBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLHNCQUFzQixvREFBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPOztBQUVBLHdFQUF3RSxxQ0FBSTtBQUNuRiwwQkFBMEIsNENBQVc7QUFDckMsK0JBQStCLHFDQUFJO0FBQ25DLGdDQUFnQywyQ0FBVTtBQUMxQzs7QUFFTyx1QkFBdUIsa0ZBQWtGLElBQUksU0FBUyxxREFBTTtBQUNuSSxPQUFPLG9EQUFjO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvREFBYztBQUNuQyw4Q0FBOEMsNENBQVc7QUFDekQsaUNBQWlDLG9EQUFjO0FBQy9DO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNCQUFzQixvREFBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUVBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG1CQUFtQixvREFBYztBQUNqQyx3QkFBd0Isb0RBQWM7QUFDdEMsMENBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBLG9DQUFvQyxvREFBYztBQUNsRDtBQUNBLEtBQUs7QUFDTCwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemVuYm9hcmQvLi9ub2RlX21vZHVsZXMveS1wcm9zZW1pcnJvci9zcmMvcGx1Z2lucy91bmRvLXBsdWdpbi5qcz9lNTIzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuaW1wb3J0IHsgZ2V0UmVsYXRpdmVTZWxlY3Rpb24gfSBmcm9tICcuL3N5bmMtcGx1Z2luLmpzJ1xuaW1wb3J0IHsgVW5kb01hbmFnZXIsIEl0ZW0sIENvbnRlbnRUeXBlLCBYbWxFbGVtZW50LCBUZXh0IH0gZnJvbSAneWpzJ1xuaW1wb3J0IHsgeVVuZG9QbHVnaW5LZXksIHlTeW5jUGx1Z2luS2V5IH0gZnJvbSAnLi9rZXlzLmpzJ1xuXG5leHBvcnQgY29uc3QgdW5kbyA9IHN0YXRlID0+IHtcbiAgY29uc3QgdW5kb01hbmFnZXIgPSB5VW5kb1BsdWdpbktleS5nZXRTdGF0ZShzdGF0ZSkudW5kb01hbmFnZXJcbiAgaWYgKHVuZG9NYW5hZ2VyICE9IG51bGwpIHtcbiAgICB1bmRvTWFuYWdlci51bmRvKClcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCByZWRvID0gc3RhdGUgPT4ge1xuICBjb25zdCB1bmRvTWFuYWdlciA9IHlVbmRvUGx1Z2luS2V5LmdldFN0YXRlKHN0YXRlKS51bmRvTWFuYWdlclxuICBpZiAodW5kb01hbmFnZXIgIT0gbnVsbCkge1xuICAgIHVuZG9NYW5hZ2VyLnJlZG8oKVxuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRQcm90ZWN0ZWROb2RlcyA9IG5ldyBTZXQoWydwYXJhZ3JhcGgnXSlcblxuZXhwb3J0IGNvbnN0IGRlZmF1bHREZWxldGVGaWx0ZXIgPSAoaXRlbSwgcHJvdGVjdGVkTm9kZXMpID0+ICEoaXRlbSBpbnN0YW5jZW9mIEl0ZW0pIHx8XG4hKGl0ZW0uY29udGVudCBpbnN0YW5jZW9mIENvbnRlbnRUeXBlKSB8fFxuIShpdGVtLmNvbnRlbnQudHlwZSBpbnN0YW5jZW9mIFRleHQgfHxcbiAgKGl0ZW0uY29udGVudC50eXBlIGluc3RhbmNlb2YgWG1sRWxlbWVudCAmJiBwcm90ZWN0ZWROb2Rlcy5oYXMoaXRlbS5jb250ZW50LnR5cGUubm9kZU5hbWUpKSkgfHxcbml0ZW0uY29udGVudC50eXBlLl9sZW5ndGggPT09IDBcblxuZXhwb3J0IGNvbnN0IHlVbmRvUGx1Z2luID0gKHsgcHJvdGVjdGVkTm9kZXMgPSBkZWZhdWx0UHJvdGVjdGVkTm9kZXMsIHRyYWNrZWRPcmlnaW5zID0gW10sIHVuZG9NYW5hZ2VyID0gbnVsbCB9ID0ge30pID0+IG5ldyBQbHVnaW4oe1xuICBrZXk6IHlVbmRvUGx1Z2luS2V5LFxuICBzdGF0ZToge1xuICAgIGluaXQ6IChpbml0YXJncywgc3RhdGUpID0+IHtcbiAgICAgIC8vIFRPRE86IGNoZWNrIGlmIHBsdWdpbiBvcmRlciBtYXRjaGVzIGFuZCBmaXhcbiAgICAgIGNvbnN0IHlzdGF0ZSA9IHlTeW5jUGx1Z2luS2V5LmdldFN0YXRlKHN0YXRlKVxuICAgICAgY29uc3QgX3VuZG9NYW5hZ2VyID0gdW5kb01hbmFnZXIgfHwgbmV3IFVuZG9NYW5hZ2VyKHlzdGF0ZS50eXBlLCB7XG4gICAgICAgIHRyYWNrZWRPcmlnaW5zOiBuZXcgU2V0KFt5U3luY1BsdWdpbktleV0uY29uY2F0KHRyYWNrZWRPcmlnaW5zKSksXG4gICAgICAgIGRlbGV0ZUZpbHRlcjogKGl0ZW0pID0+IGRlZmF1bHREZWxldGVGaWx0ZXIoaXRlbSwgcHJvdGVjdGVkTm9kZXMpXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdW5kb01hbmFnZXI6IF91bmRvTWFuYWdlcixcbiAgICAgICAgcHJldlNlbDogbnVsbCxcbiAgICAgICAgaGFzVW5kb09wczogX3VuZG9NYW5hZ2VyLnVuZG9TdGFjay5sZW5ndGggPiAwLFxuICAgICAgICBoYXNSZWRvT3BzOiBfdW5kb01hbmFnZXIucmVkb1N0YWNrLmxlbmd0aCA+IDBcbiAgICAgIH1cbiAgICB9LFxuICAgIGFwcGx5OiAodHIsIHZhbCwgb2xkU3RhdGUsIHN0YXRlKSA9PiB7XG4gICAgICBjb25zdCBiaW5kaW5nID0geVN5bmNQbHVnaW5LZXkuZ2V0U3RhdGUoc3RhdGUpLmJpbmRpbmdcbiAgICAgIGNvbnN0IHVuZG9NYW5hZ2VyID0gdmFsLnVuZG9NYW5hZ2VyXG4gICAgICBjb25zdCBoYXNVbmRvT3BzID0gdW5kb01hbmFnZXIudW5kb1N0YWNrLmxlbmd0aCA+IDBcbiAgICAgIGNvbnN0IGhhc1JlZG9PcHMgPSB1bmRvTWFuYWdlci5yZWRvU3RhY2subGVuZ3RoID4gMFxuICAgICAgaWYgKGJpbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB1bmRvTWFuYWdlcixcbiAgICAgICAgICBwcmV2U2VsOiBnZXRSZWxhdGl2ZVNlbGVjdGlvbihiaW5kaW5nLCBvbGRTdGF0ZSksXG4gICAgICAgICAgaGFzVW5kb09wcyxcbiAgICAgICAgICBoYXNSZWRvT3BzXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChoYXNVbmRvT3BzICE9PSB2YWwuaGFzVW5kb09wcyB8fCBoYXNSZWRvT3BzICE9PSB2YWwuaGFzUmVkb09wcykge1xuICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB2YWwsIHtcbiAgICAgICAgICAgIGhhc1VuZG9PcHM6IHVuZG9NYW5hZ2VyLnVuZG9TdGFjay5sZW5ndGggPiAwLFxuICAgICAgICAgICAgaGFzUmVkb09wczogdW5kb01hbmFnZXIucmVkb1N0YWNrLmxlbmd0aCA+IDBcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2UgeyAvLyBub3RoaW5nIGNoYW5nZWRcbiAgICAgICAgICByZXR1cm4gdmFsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHZpZXc6IHZpZXcgPT4ge1xuICAgIGNvbnN0IHlzdGF0ZSA9IHlTeW5jUGx1Z2luS2V5LmdldFN0YXRlKHZpZXcuc3RhdGUpXG4gICAgY29uc3QgdW5kb01hbmFnZXIgPSB5VW5kb1BsdWdpbktleS5nZXRTdGF0ZSh2aWV3LnN0YXRlKS51bmRvTWFuYWdlclxuICAgIHVuZG9NYW5hZ2VyLm9uKCdzdGFjay1pdGVtLWFkZGVkJywgKHsgc3RhY2tJdGVtIH0pID0+IHtcbiAgICAgIGNvbnN0IGJpbmRpbmcgPSB5c3RhdGUuYmluZGluZ1xuICAgICAgaWYgKGJpbmRpbmcpIHtcbiAgICAgICAgc3RhY2tJdGVtLm1ldGEuc2V0KGJpbmRpbmcsIHlVbmRvUGx1Z2luS2V5LmdldFN0YXRlKHZpZXcuc3RhdGUpLnByZXZTZWwpXG4gICAgICB9XG4gICAgfSlcbiAgICB1bmRvTWFuYWdlci5vbignc3RhY2staXRlbS1wb3BwZWQnLCAoeyBzdGFja0l0ZW0gfSkgPT4ge1xuICAgICAgY29uc3QgYmluZGluZyA9IHlzdGF0ZS5iaW5kaW5nXG4gICAgICBpZiAoYmluZGluZykge1xuICAgICAgICBiaW5kaW5nLmJlZm9yZVRyYW5zYWN0aW9uU2VsZWN0aW9uID0gc3RhY2tJdGVtLm1ldGEuZ2V0KGJpbmRpbmcpIHx8IGJpbmRpbmcuYmVmb3JlVHJhbnNhY3Rpb25TZWxlY3Rpb25cbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiB7XG4gICAgICBkZXN0cm95OiAoKSA9PiB7XG4gICAgICAgIHVuZG9NYW5hZ2VyLmRlc3Ryb3koKVxuICAgICAgfVxuICAgIH1cbiAgfVxufSlcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/y-prosemirror/src/plugins/undo-plugin.js\n");

/***/ })

};
;