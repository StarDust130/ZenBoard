"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@edgestore";
exports.ids = ["vendor-chunks/@edgestore"];
exports.modules = {

/***/ "(ssr)/./node_modules/@edgestore/react/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@edgestore/react/dist/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createEdgeStoreProvider: () => (/* binding */ createEdgeStoreProvider)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\nclass EdgeStoreError extends Error {\n    constructor(message){\n        super(message);\n        this.name = 'EdgeStoreError';\n    }\n}\n\nfunction createNextProxy({ apiPath, uploadingCountRef, maxConcurrentUploads = 5 }) {\n    return new Proxy({}, {\n        get (_, prop) {\n            const bucketName = prop;\n            const bucketFunctions = {\n                upload: async (params)=>{\n                    try {\n                        params.onProgressChange?.(0);\n                        while(uploadingCountRef.current >= maxConcurrentUploads && uploadingCountRef.current > 0){\n                            await new Promise((resolve)=>setTimeout(resolve, 300));\n                        }\n                        uploadingCountRef.current++;\n                        return await uploadFile(params, {\n                            bucketName: bucketName,\n                            apiPath\n                        });\n                    } finally{\n                        uploadingCountRef.current--;\n                    }\n                },\n                confirmUpload: async (params)=>{\n                    const { success } = await confirmUpload(params, {\n                        bucketName: bucketName,\n                        apiPath\n                    });\n                    if (!success) {\n                        throw new EdgeStoreError('Failed to confirm upload');\n                    }\n                },\n                delete: async (params)=>{\n                    const { success } = await deleteFile(params, {\n                        bucketName: bucketName,\n                        apiPath\n                    });\n                    if (!success) {\n                        throw new EdgeStoreError('Failed to delete file');\n                    }\n                }\n            };\n            return bucketFunctions;\n        }\n    });\n}\nasync function uploadFile({ file, input, onProgressChange, options }, { apiPath, bucketName }) {\n    try {\n        onProgressChange?.(0);\n        const res = await fetch(`${apiPath}/request-upload`, {\n            method: 'POST',\n            body: JSON.stringify({\n                bucketName,\n                input,\n                fileInfo: {\n                    extension: file.name.split('.').pop(),\n                    type: file.type,\n                    size: file.size,\n                    fileName: options?.manualFileName,\n                    replaceTargetUrl: options?.replaceTargetUrl,\n                    temporary: options?.temporary\n                }\n            }),\n            headers: {\n                'Content-Type': 'application/json'\n            }\n        });\n        const json = await res.json();\n        if ('multipart' in json) {\n            await multipartUpload({\n                bucketName,\n                multipartInfo: json.multipart,\n                onProgressChange,\n                file,\n                apiPath\n            });\n        } else if ('uploadUrl' in json) {\n            // Single part upload\n            // Upload the file to the signed URL and get the progress\n            await uploadFileInner(file, json.uploadUrl, onProgressChange);\n        } else {\n            throw new EdgeStoreError('An error occurred');\n        }\n        return {\n            url: getUrl(json.accessUrl, apiPath),\n            thumbnailUrl: json.thumbnailUrl ? getUrl(json.thumbnailUrl, apiPath) : null,\n            size: json.size,\n            uploadedAt: new Date(json.uploadedAt),\n            path: json.path,\n            pathOrder: json.pathOrder,\n            metadata: json.metadata\n        };\n    } catch (e) {\n        onProgressChange?.(0);\n        throw e;\n    }\n}\n/**\n * Protected files need third-party cookies to work.\n * Since third party cookies doesn't work on localhost,\n * we need to proxy the file through the server.\n */ function getUrl(url, apiPath) {\n    if ( true && !url.includes('/_public/')) {\n        const proxyUrl = new URL(window.location.origin);\n        proxyUrl.pathname = `${apiPath}/proxy-file`;\n        proxyUrl.search = new URLSearchParams({\n            url\n        }).toString();\n        return proxyUrl.toString();\n    }\n    return url;\n}\nconst uploadFileInner = async (file, uploadUrl, onProgressChange)=>{\n    const promise = new Promise((resolve, reject)=>{\n        const request = new XMLHttpRequest();\n        request.open('PUT', uploadUrl);\n        request.addEventListener('loadstart', ()=>{\n            onProgressChange?.(0);\n        });\n        request.upload.addEventListener('progress', (e)=>{\n            if (e.lengthComputable) {\n                // 2 decimal progress\n                const progress = Math.round(e.loaded / e.total * 10000) / 100;\n                onProgressChange?.(progress);\n            }\n        });\n        request.addEventListener('error', ()=>{\n            reject(new Error('Error uploading file'));\n        });\n        request.addEventListener('abort', ()=>{\n            reject(new Error('File upload aborted'));\n        });\n        request.addEventListener('loadend', ()=>{\n            // Return the ETag header (needed to complete multipart upload)\n            resolve(request.getResponseHeader('ETag'));\n        });\n        request.send(file);\n    });\n    return promise;\n};\nasync function multipartUpload(params) {\n    const { bucketName, multipartInfo, onProgressChange, file, apiPath } = params;\n    const { partSize, parts, totalParts, uploadId, key } = multipartInfo;\n    const uploadingParts = [];\n    const uploadPart = async (params)=>{\n        const { part, chunk } = params;\n        const { uploadUrl } = part;\n        const eTag = await uploadFileInner(chunk, uploadUrl, (progress)=>{\n            const uploadingPart = uploadingParts.find((p)=>p.partNumber === part.partNumber);\n            if (uploadingPart) {\n                uploadingPart.progress = progress;\n            } else {\n                uploadingParts.push({\n                    partNumber: part.partNumber,\n                    progress\n                });\n            }\n            const totalProgress = Math.round(uploadingParts.reduce((acc, p)=>acc + p.progress * 100, 0) / totalParts) / 100;\n            onProgressChange?.(totalProgress);\n        });\n        if (!eTag) {\n            throw new EdgeStoreError('Could not get ETag from multipart response');\n        }\n        return {\n            partNumber: part.partNumber,\n            eTag\n        };\n    };\n    // Upload the parts in parallel\n    const completedParts = await queuedPromises({\n        items: parts.map((part)=>({\n                part,\n                chunk: file.slice((part.partNumber - 1) * partSize, part.partNumber * partSize)\n            })),\n        fn: uploadPart,\n        maxParallel: 5,\n        maxRetries: 10\n    });\n    // Complete multipart upload\n    const res = await fetch(`${apiPath}/complete-multipart-upload`, {\n        method: 'POST',\n        body: JSON.stringify({\n            bucketName,\n            uploadId,\n            key,\n            parts: completedParts\n        }),\n        headers: {\n            'Content-Type': 'application/json'\n        }\n    });\n    if (!res.ok) {\n        throw new EdgeStoreError('Multi-part upload failed');\n    }\n}\nasync function confirmUpload({ url }, { apiPath, bucketName }) {\n    const res = await fetch(`${apiPath}/confirm-upload`, {\n        method: 'POST',\n        body: JSON.stringify({\n            url,\n            bucketName\n        }),\n        headers: {\n            'Content-Type': 'application/json'\n        }\n    });\n    if (!res.ok) {\n        throw new EdgeStoreError('An error occurred');\n    }\n    return res.json();\n}\nasync function deleteFile({ url }, { apiPath, bucketName }) {\n    const res = await fetch(`${apiPath}/delete-file`, {\n        method: 'POST',\n        body: JSON.stringify({\n            url,\n            bucketName\n        }),\n        headers: {\n            'Content-Type': 'application/json'\n        }\n    });\n    if (!res.ok) {\n        throw new EdgeStoreError('An error occurred');\n    }\n    return res.json();\n}\nasync function queuedPromises({ items, fn, maxParallel, maxRetries = 0 }) {\n    const results = new Array(items.length);\n    const executeWithRetry = async (func, retries)=>{\n        try {\n            return await func();\n        } catch (error) {\n            if (retries > 0) {\n                await new Promise((resolve)=>setTimeout(resolve, 5000));\n                return executeWithRetry(func, retries - 1);\n            } else {\n                throw error;\n            }\n        }\n    };\n    const semaphore = {\n        count: maxParallel,\n        async wait () {\n            // If we've reached our maximum concurrency or it's the last item, wait\n            while(this.count <= 0)await new Promise((resolve)=>setTimeout(resolve, 500));\n            this.count--;\n        },\n        signal () {\n            this.count++;\n        }\n    };\n    const tasks = items.map((item, i)=>(async ()=>{\n            await semaphore.wait();\n            try {\n                const result = await executeWithRetry(()=>fn(item), maxRetries);\n                results[i] = result;\n            } finally{\n                semaphore.signal();\n            }\n        })());\n    await Promise.all(tasks);\n    return results;\n}\n\nconst DEFAULT_BASE_URL = process.env.NEXT_PUBLIC_EDGE_STORE_BASE_URL ?? 'https://files.edgestore.dev';\nfunction createEdgeStoreProvider(opts) {\n    const EdgeStoreContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(undefined);\n    const EdgeStoreProvider = ({ children, basePath })=>{\n        return EdgeStoreProviderInner({\n            children,\n            context: EdgeStoreContext,\n            basePath,\n            maxConcurrentUploads: opts?.maxConcurrentUploads\n        });\n    };\n    function useEdgeStore() {\n        if (!EdgeStoreContext) {\n            throw new Error('React Context is unavailable in Server Components');\n        }\n        // @ts-expect-error - We know that the context value should not be undefined\n        const value = react__WEBPACK_IMPORTED_MODULE_0__.useContext(EdgeStoreContext);\n        if (!value && \"development\" !== 'production') {\n            throw new Error('[edgestore]: `useEdgeStore` must be wrapped in a <EdgeStoreProvider />');\n        }\n        return value;\n    }\n    return {\n        EdgeStoreProvider,\n        useEdgeStore\n    };\n}\nfunction EdgeStoreProviderInner({ children, context, basePath, maxConcurrentUploads }) {\n    const apiPath = basePath ? `${basePath}` : '/api/edgestore';\n    const uploadingCountRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        void init();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    async function init() {\n        const res = await fetch(`${apiPath}/init`, {\n            method: 'POST'\n        });\n        if (res.ok) {\n            const json = await res.json();\n            await fetch(`${DEFAULT_BASE_URL}/_init`, {\n                method: 'GET',\n                headers: {\n                    'x-edgestore-token': json.token\n                }\n            });\n        }\n    }\n    async function reset() {\n        await init();\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(context.Provider, {\n        value: {\n            edgestore: createNextProxy({\n                apiPath,\n                uploadingCountRef,\n                maxConcurrentUploads\n            }),\n            reset\n        }\n    }, children));\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGVkZ2VzdG9yZS9yZWFjdC9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixzREFBc0Q7QUFDakYsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsNEJBQTRCLFVBQVU7QUFDdEM7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNEJBQTRCLHdDQUF3QyxJQUFJLHFCQUFxQjtBQUM3RjtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXNDO0FBQzlDO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZEQUE2RDtBQUN6RSxZQUFZLDZDQUE2QztBQUN6RDtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwrQkFBK0IsUUFBUTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUssSUFBSSxxQkFBcUI7QUFDN0QsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsS0FBSyxJQUFJLHFCQUFxQjtBQUMxRCwrQkFBK0IsUUFBUTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx3Q0FBd0M7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLGdEQUFtQjtBQUM5RCxpQ0FBaUMsb0JBQW9CO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDZDQUFnQjtBQUN0QyxzQkFBc0IsYUFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG1EQUFtRDtBQUNyRixrQ0FBa0MsU0FBUztBQUMzQyw4QkFBOEIseUNBQVk7QUFDMUMsSUFBSSw0Q0FBZTtBQUNuQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnREFBbUIsQ0FBQywyQ0FBYyxzQkFBc0IsZ0RBQW1CO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96ZW5ib2FyZC8uL25vZGVfbW9kdWxlcy9AZWRnZXN0b3JlL3JlYWN0L2Rpc3QvaW5kZXgubWpzP2RkNmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5jbGFzcyBFZGdlU3RvcmVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKXtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdFZGdlU3RvcmVFcnJvcic7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVOZXh0UHJveHkoeyBhcGlQYXRoLCB1cGxvYWRpbmdDb3VudFJlZiwgbWF4Q29uY3VycmVudFVwbG9hZHMgPSA1IH0pIHtcbiAgICByZXR1cm4gbmV3IFByb3h5KHt9LCB7XG4gICAgICAgIGdldCAoXywgcHJvcCkge1xuICAgICAgICAgICAgY29uc3QgYnVja2V0TmFtZSA9IHByb3A7XG4gICAgICAgICAgICBjb25zdCBidWNrZXRGdW5jdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgdXBsb2FkOiBhc3luYyAocGFyYW1zKT0+e1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLm9uUHJvZ3Jlc3NDaGFuZ2U/LigwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKHVwbG9hZGluZ0NvdW50UmVmLmN1cnJlbnQgPj0gbWF4Q29uY3VycmVudFVwbG9hZHMgJiYgdXBsb2FkaW5nQ291bnRSZWYuY3VycmVudCA+IDApe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKT0+c2V0VGltZW91dChyZXNvbHZlLCAzMDApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHVwbG9hZGluZ0NvdW50UmVmLmN1cnJlbnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB1cGxvYWRGaWxlKHBhcmFtcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1Y2tldE5hbWU6IGJ1Y2tldE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpUGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwbG9hZGluZ0NvdW50UmVmLmN1cnJlbnQtLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29uZmlybVVwbG9hZDogYXN5bmMgKHBhcmFtcyk9PntcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzdWNjZXNzIH0gPSBhd2FpdCBjb25maXJtVXBsb2FkKHBhcmFtcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVja2V0TmFtZTogYnVja2V0TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaVBhdGhcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVkZ2VTdG9yZUVycm9yKCdGYWlsZWQgdG8gY29uZmlybSB1cGxvYWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVsZXRlOiBhc3luYyAocGFyYW1zKT0+e1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHN1Y2Nlc3MgfSA9IGF3YWl0IGRlbGV0ZUZpbGUocGFyYW1zLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWNrZXROYW1lOiBidWNrZXROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXBpUGF0aFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRWRnZVN0b3JlRXJyb3IoJ0ZhaWxlZCB0byBkZWxldGUgZmlsZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBidWNrZXRGdW5jdGlvbnM7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHVwbG9hZEZpbGUoeyBmaWxlLCBpbnB1dCwgb25Qcm9ncmVzc0NoYW5nZSwgb3B0aW9ucyB9LCB7IGFwaVBhdGgsIGJ1Y2tldE5hbWUgfSkge1xuICAgIHRyeSB7XG4gICAgICAgIG9uUHJvZ3Jlc3NDaGFuZ2U/LigwKTtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYCR7YXBpUGF0aH0vcmVxdWVzdC11cGxvYWRgLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBidWNrZXROYW1lLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGZpbGVJbmZvOiB7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbjogZmlsZS5uYW1lLnNwbGl0KCcuJykucG9wKCksXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGZpbGUudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogZmlsZS5zaXplLFxuICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZTogb3B0aW9ucz8ubWFudWFsRmlsZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VUYXJnZXRVcmw6IG9wdGlvbnM/LnJlcGxhY2VUYXJnZXRVcmwsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBvcmFyeTogb3B0aW9ucz8udGVtcG9yYXJ5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QganNvbiA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgICAgIGlmICgnbXVsdGlwYXJ0JyBpbiBqc29uKSB7XG4gICAgICAgICAgICBhd2FpdCBtdWx0aXBhcnRVcGxvYWQoe1xuICAgICAgICAgICAgICAgIGJ1Y2tldE5hbWUsXG4gICAgICAgICAgICAgICAgbXVsdGlwYXJ0SW5mbzoganNvbi5tdWx0aXBhcnQsXG4gICAgICAgICAgICAgICAgb25Qcm9ncmVzc0NoYW5nZSxcbiAgICAgICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgICAgIGFwaVBhdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKCd1cGxvYWRVcmwnIGluIGpzb24pIHtcbiAgICAgICAgICAgIC8vIFNpbmdsZSBwYXJ0IHVwbG9hZFxuICAgICAgICAgICAgLy8gVXBsb2FkIHRoZSBmaWxlIHRvIHRoZSBzaWduZWQgVVJMIGFuZCBnZXQgdGhlIHByb2dyZXNzXG4gICAgICAgICAgICBhd2FpdCB1cGxvYWRGaWxlSW5uZXIoZmlsZSwganNvbi51cGxvYWRVcmwsIG9uUHJvZ3Jlc3NDaGFuZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVkZ2VTdG9yZUVycm9yKCdBbiBlcnJvciBvY2N1cnJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1cmw6IGdldFVybChqc29uLmFjY2Vzc1VybCwgYXBpUGF0aCksXG4gICAgICAgICAgICB0aHVtYm5haWxVcmw6IGpzb24udGh1bWJuYWlsVXJsID8gZ2V0VXJsKGpzb24udGh1bWJuYWlsVXJsLCBhcGlQYXRoKSA6IG51bGwsXG4gICAgICAgICAgICBzaXplOiBqc29uLnNpemUsXG4gICAgICAgICAgICB1cGxvYWRlZEF0OiBuZXcgRGF0ZShqc29uLnVwbG9hZGVkQXQpLFxuICAgICAgICAgICAgcGF0aDoganNvbi5wYXRoLFxuICAgICAgICAgICAgcGF0aE9yZGVyOiBqc29uLnBhdGhPcmRlcixcbiAgICAgICAgICAgIG1ldGFkYXRhOiBqc29uLm1ldGFkYXRhXG4gICAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBvblByb2dyZXNzQ2hhbmdlPy4oMCk7XG4gICAgICAgIHRocm93IGU7XG4gICAgfVxufVxuLyoqXG4gKiBQcm90ZWN0ZWQgZmlsZXMgbmVlZCB0aGlyZC1wYXJ0eSBjb29raWVzIHRvIHdvcmsuXG4gKiBTaW5jZSB0aGlyZCBwYXJ0eSBjb29raWVzIGRvZXNuJ3Qgd29yayBvbiBsb2NhbGhvc3QsXG4gKiB3ZSBuZWVkIHRvIHByb3h5IHRoZSBmaWxlIHRocm91Z2ggdGhlIHNlcnZlci5cbiAqLyBmdW5jdGlvbiBnZXRVcmwodXJsLCBhcGlQYXRoKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICF1cmwuaW5jbHVkZXMoJy9fcHVibGljLycpKSB7XG4gICAgICAgIGNvbnN0IHByb3h5VXJsID0gbmV3IFVSTCh3aW5kb3cubG9jYXRpb24ub3JpZ2luKTtcbiAgICAgICAgcHJveHlVcmwucGF0aG5hbWUgPSBgJHthcGlQYXRofS9wcm94eS1maWxlYDtcbiAgICAgICAgcHJveHlVcmwuc2VhcmNoID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgICAgICB1cmxcbiAgICAgICAgfSkudG9TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIHByb3h5VXJsLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiB1cmw7XG59XG5jb25zdCB1cGxvYWRGaWxlSW5uZXIgPSBhc3luYyAoZmlsZSwgdXBsb2FkVXJsLCBvblByb2dyZXNzQ2hhbmdlKT0+e1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KT0+e1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHJlcXVlc3Qub3BlbignUFVUJywgdXBsb2FkVXJsKTtcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdsb2Fkc3RhcnQnLCAoKT0+e1xuICAgICAgICAgICAgb25Qcm9ncmVzc0NoYW5nZT8uKDApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVxdWVzdC51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCAoZSk9PntcbiAgICAgICAgICAgIGlmIChlLmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgICAgICAgICAgICAvLyAyIGRlY2ltYWwgcHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9ncmVzcyA9IE1hdGgucm91bmQoZS5sb2FkZWQgLyBlLnRvdGFsICogMTAwMDApIC8gMTAwO1xuICAgICAgICAgICAgICAgIG9uUHJvZ3Jlc3NDaGFuZ2U/Lihwcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgKCk9PntcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0Vycm9yIHVwbG9hZGluZyBmaWxlJykpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpPT57XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdGaWxlIHVwbG9hZCBhYm9ydGVkJykpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdsb2FkZW5kJywgKCk9PntcbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgRVRhZyBoZWFkZXIgKG5lZWRlZCB0byBjb21wbGV0ZSBtdWx0aXBhcnQgdXBsb2FkKVxuICAgICAgICAgICAgcmVzb2x2ZShyZXF1ZXN0LmdldFJlc3BvbnNlSGVhZGVyKCdFVGFnJykpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVxdWVzdC5zZW5kKGZpbGUpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xufTtcbmFzeW5jIGZ1bmN0aW9uIG11bHRpcGFydFVwbG9hZChwYXJhbXMpIHtcbiAgICBjb25zdCB7IGJ1Y2tldE5hbWUsIG11bHRpcGFydEluZm8sIG9uUHJvZ3Jlc3NDaGFuZ2UsIGZpbGUsIGFwaVBhdGggfSA9IHBhcmFtcztcbiAgICBjb25zdCB7IHBhcnRTaXplLCBwYXJ0cywgdG90YWxQYXJ0cywgdXBsb2FkSWQsIGtleSB9ID0gbXVsdGlwYXJ0SW5mbztcbiAgICBjb25zdCB1cGxvYWRpbmdQYXJ0cyA9IFtdO1xuICAgIGNvbnN0IHVwbG9hZFBhcnQgPSBhc3luYyAocGFyYW1zKT0+e1xuICAgICAgICBjb25zdCB7IHBhcnQsIGNodW5rIH0gPSBwYXJhbXM7XG4gICAgICAgIGNvbnN0IHsgdXBsb2FkVXJsIH0gPSBwYXJ0O1xuICAgICAgICBjb25zdCBlVGFnID0gYXdhaXQgdXBsb2FkRmlsZUlubmVyKGNodW5rLCB1cGxvYWRVcmwsIChwcm9ncmVzcyk9PntcbiAgICAgICAgICAgIGNvbnN0IHVwbG9hZGluZ1BhcnQgPSB1cGxvYWRpbmdQYXJ0cy5maW5kKChwKT0+cC5wYXJ0TnVtYmVyID09PSBwYXJ0LnBhcnROdW1iZXIpO1xuICAgICAgICAgICAgaWYgKHVwbG9hZGluZ1BhcnQpIHtcbiAgICAgICAgICAgICAgICB1cGxvYWRpbmdQYXJ0LnByb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVwbG9hZGluZ1BhcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBwYXJ0TnVtYmVyOiBwYXJ0LnBhcnROdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0b3RhbFByb2dyZXNzID0gTWF0aC5yb3VuZCh1cGxvYWRpbmdQYXJ0cy5yZWR1Y2UoKGFjYywgcCk9PmFjYyArIHAucHJvZ3Jlc3MgKiAxMDAsIDApIC8gdG90YWxQYXJ0cykgLyAxMDA7XG4gICAgICAgICAgICBvblByb2dyZXNzQ2hhbmdlPy4odG90YWxQcm9ncmVzcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWVUYWcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFZGdlU3RvcmVFcnJvcignQ291bGQgbm90IGdldCBFVGFnIGZyb20gbXVsdGlwYXJ0IHJlc3BvbnNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhcnROdW1iZXI6IHBhcnQucGFydE51bWJlcixcbiAgICAgICAgICAgIGVUYWdcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8vIFVwbG9hZCB0aGUgcGFydHMgaW4gcGFyYWxsZWxcbiAgICBjb25zdCBjb21wbGV0ZWRQYXJ0cyA9IGF3YWl0IHF1ZXVlZFByb21pc2VzKHtcbiAgICAgICAgaXRlbXM6IHBhcnRzLm1hcCgocGFydCk9Pih7XG4gICAgICAgICAgICAgICAgcGFydCxcbiAgICAgICAgICAgICAgICBjaHVuazogZmlsZS5zbGljZSgocGFydC5wYXJ0TnVtYmVyIC0gMSkgKiBwYXJ0U2l6ZSwgcGFydC5wYXJ0TnVtYmVyICogcGFydFNpemUpXG4gICAgICAgICAgICB9KSksXG4gICAgICAgIGZuOiB1cGxvYWRQYXJ0LFxuICAgICAgICBtYXhQYXJhbGxlbDogNSxcbiAgICAgICAgbWF4UmV0cmllczogMTBcbiAgICB9KTtcbiAgICAvLyBDb21wbGV0ZSBtdWx0aXBhcnQgdXBsb2FkXG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYCR7YXBpUGF0aH0vY29tcGxldGUtbXVsdGlwYXJ0LXVwbG9hZGAsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIGJ1Y2tldE5hbWUsXG4gICAgICAgICAgICB1cGxvYWRJZCxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHBhcnRzOiBjb21wbGV0ZWRQYXJ0c1xuICAgICAgICB9KSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVkZ2VTdG9yZUVycm9yKCdNdWx0aS1wYXJ0IHVwbG9hZCBmYWlsZWQnKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBjb25maXJtVXBsb2FkKHsgdXJsIH0sIHsgYXBpUGF0aCwgYnVja2V0TmFtZSB9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYCR7YXBpUGF0aH0vY29uZmlybS11cGxvYWRgLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBidWNrZXROYW1lXG4gICAgICAgIH0pLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRWRnZVN0b3JlRXJyb3IoJ0FuIGVycm9yIG9jY3VycmVkJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMuanNvbigpO1xufVxuYXN5bmMgZnVuY3Rpb24gZGVsZXRlRmlsZSh7IHVybCB9LCB7IGFwaVBhdGgsIGJ1Y2tldE5hbWUgfSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAke2FwaVBhdGh9L2RlbGV0ZS1maWxlYCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgYnVja2V0TmFtZVxuICAgICAgICB9KSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVkZ2VTdG9yZUVycm9yKCdBbiBlcnJvciBvY2N1cnJlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLmpzb24oKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHF1ZXVlZFByb21pc2VzKHsgaXRlbXMsIGZuLCBtYXhQYXJhbGxlbCwgbWF4UmV0cmllcyA9IDAgfSkge1xuICAgIGNvbnN0IHJlc3VsdHMgPSBuZXcgQXJyYXkoaXRlbXMubGVuZ3RoKTtcbiAgICBjb25zdCBleGVjdXRlV2l0aFJldHJ5ID0gYXN5bmMgKGZ1bmMsIHJldHJpZXMpPT57XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgZnVuYygpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKHJldHJpZXMgPiAwKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpPT5zZXRUaW1lb3V0KHJlc29sdmUsIDUwMDApKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhlY3V0ZVdpdGhSZXRyeShmdW5jLCByZXRyaWVzIC0gMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzZW1hcGhvcmUgPSB7XG4gICAgICAgIGNvdW50OiBtYXhQYXJhbGxlbCxcbiAgICAgICAgYXN5bmMgd2FpdCAoKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSd2ZSByZWFjaGVkIG91ciBtYXhpbXVtIGNvbmN1cnJlbmN5IG9yIGl0J3MgdGhlIGxhc3QgaXRlbSwgd2FpdFxuICAgICAgICAgICAgd2hpbGUodGhpcy5jb3VudCA8PSAwKWF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKT0+c2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcbiAgICAgICAgICAgIHRoaXMuY291bnQtLTtcbiAgICAgICAgfSxcbiAgICAgICAgc2lnbmFsICgpIHtcbiAgICAgICAgICAgIHRoaXMuY291bnQrKztcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgdGFza3MgPSBpdGVtcy5tYXAoKGl0ZW0sIGkpPT4oYXN5bmMgKCk9PntcbiAgICAgICAgICAgIGF3YWl0IHNlbWFwaG9yZS53YWl0KCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV4ZWN1dGVXaXRoUmV0cnkoKCk9PmZuKGl0ZW0pLCBtYXhSZXRyaWVzKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzW2ldID0gcmVzdWx0O1xuICAgICAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgICAgIHNlbWFwaG9yZS5zaWduYWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKSk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwodGFza3MpO1xuICAgIHJldHVybiByZXN1bHRzO1xufVxuXG5jb25zdCBERUZBVUxUX0JBU0VfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRURHRV9TVE9SRV9CQVNFX1VSTCA/PyAnaHR0cHM6Ly9maWxlcy5lZGdlc3RvcmUuZGV2JztcbmZ1bmN0aW9uIGNyZWF0ZUVkZ2VTdG9yZVByb3ZpZGVyKG9wdHMpIHtcbiAgICBjb25zdCBFZGdlU3RvcmVDb250ZXh0ID0gLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XG4gICAgY29uc3QgRWRnZVN0b3JlUHJvdmlkZXIgPSAoeyBjaGlsZHJlbiwgYmFzZVBhdGggfSk9PntcbiAgICAgICAgcmV0dXJuIEVkZ2VTdG9yZVByb3ZpZGVySW5uZXIoe1xuICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICBjb250ZXh0OiBFZGdlU3RvcmVDb250ZXh0LFxuICAgICAgICAgICAgYmFzZVBhdGgsXG4gICAgICAgICAgICBtYXhDb25jdXJyZW50VXBsb2Fkczogb3B0cz8ubWF4Q29uY3VycmVudFVwbG9hZHNcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiB1c2VFZGdlU3RvcmUoKSB7XG4gICAgICAgIGlmICghRWRnZVN0b3JlQ29udGV4dCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWFjdCBDb250ZXh0IGlzIHVuYXZhaWxhYmxlIGluIFNlcnZlciBDb21wb25lbnRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIFdlIGtub3cgdGhhdCB0aGUgY29udGV4dCB2YWx1ZSBzaG91bGQgbm90IGJlIHVuZGVmaW5lZFxuICAgICAgICBjb25zdCB2YWx1ZSA9IFJlYWN0LnVzZUNvbnRleHQoRWRnZVN0b3JlQ29udGV4dCk7XG4gICAgICAgIGlmICghdmFsdWUgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbZWRnZXN0b3JlXTogYHVzZUVkZ2VTdG9yZWAgbXVzdCBiZSB3cmFwcGVkIGluIGEgPEVkZ2VTdG9yZVByb3ZpZGVyIC8+Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBFZGdlU3RvcmVQcm92aWRlcixcbiAgICAgICAgdXNlRWRnZVN0b3JlXG4gICAgfTtcbn1cbmZ1bmN0aW9uIEVkZ2VTdG9yZVByb3ZpZGVySW5uZXIoeyBjaGlsZHJlbiwgY29udGV4dCwgYmFzZVBhdGgsIG1heENvbmN1cnJlbnRVcGxvYWRzIH0pIHtcbiAgICBjb25zdCBhcGlQYXRoID0gYmFzZVBhdGggPyBgJHtiYXNlUGF0aH1gIDogJy9hcGkvZWRnZXN0b3JlJztcbiAgICBjb25zdCB1cGxvYWRpbmdDb3VudFJlZiA9IFJlYWN0LnVzZVJlZigwKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgdm9pZCBpbml0KCk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIH0sIFtdKTtcbiAgICBhc3luYyBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgJHthcGlQYXRofS9pbml0YCwge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCdcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXMub2spIHtcbiAgICAgICAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXMuanNvbigpO1xuICAgICAgICAgICAgYXdhaXQgZmV0Y2goYCR7REVGQVVMVF9CQVNFX1VSTH0vX2luaXRgLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICd4LWVkZ2VzdG9yZS10b2tlbic6IGpzb24udG9rZW5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgYXdhaXQgaW5pdCgpO1xuICAgIH1cbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoY29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgZWRnZXN0b3JlOiBjcmVhdGVOZXh0UHJveHkoe1xuICAgICAgICAgICAgICAgIGFwaVBhdGgsXG4gICAgICAgICAgICAgICAgdXBsb2FkaW5nQ291bnRSZWYsXG4gICAgICAgICAgICAgICAgbWF4Q29uY3VycmVudFVwbG9hZHNcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcmVzZXRcbiAgICAgICAgfVxuICAgIH0sIGNoaWxkcmVuKSk7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZUVkZ2VTdG9yZVByb3ZpZGVyIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@edgestore/react/dist/index.mjs\n");

/***/ })

};
;